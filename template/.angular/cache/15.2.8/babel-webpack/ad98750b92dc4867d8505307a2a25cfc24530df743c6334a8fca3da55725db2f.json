{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Directive, EventEmitter, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { Subject, Observable, ReplaySubject, merge, combineLatest, fromEvent } from 'rxjs';\nimport { filter, mergeMap, startWith, map, share, takeUntil, take, takeLast, count, pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(className => renderer.addClass(element.nativeElement, className));\n  }\n}\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(className => renderer.removeClass(element.nativeElement, className));\n  }\n}\nclass DraggableHelper {\n  constructor() {\n    this.currentDrag = new Subject();\n  }\n}\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\nDraggableHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableHelper, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\nclass DraggableScrollContainerDirective {\n  /**\n   * @hidden\n   */\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n}\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n  return new (t || DraggableScrollContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\nDraggableScrollContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DraggableScrollContainerDirective,\n  selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggableScrollContainer]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }];\n  }, null);\n})();\nclass DraggableDirective {\n  /**\n   * @hidden\n   */\n  constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.vcr = vcr;\n    this.scrollContainer = scrollContainer;\n    this.document = document;\n    /**\n     * The axis along which the element is draggable\n     */\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\n     * Snap all drags to an x / y grid\n     */\n    this.dragSnapGrid = {};\n    /**\n     * Show a ghost element that shows the drag when dragging\n     */\n    this.ghostDragEnabled = true;\n    /**\n     * Show the original element when ghostDragEnabled is true\n     */\n    this.showOriginalElementWhileDragging = false;\n    /**\n     * The cursor to use when hovering over a draggable element\n     */\n    this.dragCursor = '';\n    /*\n     * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n     */\n    this.autoScroll = {\n      margin: 20\n    };\n    /**\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n     */\n    this.dragPointerDown = new EventEmitter();\n    /**\n     * Called when the element has started to be dragged.\n     * Only called after at least one mouse or touch move event.\n     * If you call $event.cancelDrag$.emit() it will cancel the current drag\n     */\n    this.dragStart = new EventEmitter();\n    /**\n     * Called after the ghost element has been created\n     */\n    this.ghostElementCreated = new EventEmitter();\n    /**\n     * Called when the element is being dragged\n     */\n    this.dragging = new EventEmitter();\n    /**\n     * Called after the element is dragged\n     */\n    this.dragEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n    this.pointerDown$ = new Subject();\n    /**\n     * @hidden\n     */\n    this.pointerMove$ = new Subject();\n    /**\n     * @hidden\n     */\n    this.pointerUp$ = new Subject();\n    this.eventListenerSubscriptions = {};\n    this.destroy$ = new Subject();\n    this.timeLongPress = {\n      timerBegin: 0,\n      timerEnd: 0\n    };\n  }\n  ngOnInit() {\n    this.checkEventListeners();\n    const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap(pointerDownEvent => {\n      // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n      // stop mouse events propagating up the chain\n      if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n        pointerDownEvent.event.stopPropagation();\n      }\n      // hack to prevent text getting selected in safari while dragging\n      const globalDragStyle = this.renderer.createElement('style');\n      this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n      this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n      requestAnimationFrame(() => {\n        this.document.head.appendChild(globalDragStyle);\n      });\n      const startScrollPosition = this.getScrollPosition();\n      const scrollContainerScroll$ = new Observable(observer => {\n        const scrollContainer = this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window';\n        return this.renderer.listen(scrollContainer, 'scroll', e => observer.next(e));\n      }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));\n      const currentDrag$ = new Subject();\n      const cancelDrag$ = new ReplaySubject();\n      if (this.dragPointerDown.observers.length > 0) {\n        this.zone.run(() => {\n          this.dragPointerDown.next({\n            x: 0,\n            y: 0\n          });\n        });\n      }\n      const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n      const pointerMove = combineLatest([this.pointerMove$, scrollContainerScroll$]).pipe(map(([pointerMoveEvent, scroll]) => {\n        return {\n          currentDrag$,\n          transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n          transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n          clientX: pointerMoveEvent.clientX,\n          clientY: pointerMoveEvent.clientY,\n          scrollLeft: scroll.left,\n          scrollTop: scroll.top,\n          target: pointerMoveEvent.event.target\n        };\n      }), map(moveData => {\n        if (this.dragSnapGrid.x) {\n          moveData.transformX = Math.round(moveData.transformX / this.dragSnapGrid.x) * this.dragSnapGrid.x;\n        }\n        if (this.dragSnapGrid.y) {\n          moveData.transformY = Math.round(moveData.transformY / this.dragSnapGrid.y) * this.dragSnapGrid.y;\n        }\n        return moveData;\n      }), map(moveData => {\n        if (!this.dragAxis.x) {\n          moveData.transformX = 0;\n        }\n        if (!this.dragAxis.y) {\n          moveData.transformY = 0;\n        }\n        return moveData;\n      }), map(moveData => {\n        const scrollX = moveData.scrollLeft - startScrollPosition.left;\n        const scrollY = moveData.scrollTop - startScrollPosition.top;\n        return {\n          ...moveData,\n          x: moveData.transformX + scrollX,\n          y: moveData.transformY + scrollY\n        };\n      }), filter(({\n        x,\n        y,\n        transformX,\n        transformY\n      }) => !this.validateDrag || this.validateDrag({\n        x,\n        y,\n        transform: {\n          x: transformX,\n          y: transformY\n        }\n      })), takeUntil(dragComplete$), share());\n      const dragStarted$ = pointerMove.pipe(take(1), share());\n      const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n      dragStarted$.subscribe(({\n        clientX,\n        clientY,\n        x,\n        y\n      }) => {\n        if (this.dragStart.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragStart.next({\n              cancelDrag$\n            });\n          });\n        }\n        this.scroller = autoScroll([this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : this.document.defaultView], {\n          ...this.autoScroll,\n          autoScroll() {\n            return true;\n          }\n        });\n        addClass(this.renderer, this.element, this.dragActiveClass);\n        if (this.ghostDragEnabled) {\n          const rect = this.element.nativeElement.getBoundingClientRect();\n          const clone = this.element.nativeElement.cloneNode(true);\n          if (!this.showOriginalElementWhileDragging) {\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n          }\n          if (this.ghostElementAppendTo) {\n            this.ghostElementAppendTo.appendChild(clone);\n          } else {\n            this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n          }\n          this.ghostElement = clone;\n          this.document.body.style.cursor = this.dragCursor;\n          this.setElementStyles(clone, {\n            position: 'fixed',\n            top: `${rect.top}px`,\n            left: `${rect.left}px`,\n            width: `${rect.width}px`,\n            height: `${rect.height}px`,\n            cursor: this.dragCursor,\n            margin: '0',\n            willChange: 'transform',\n            pointerEvents: 'none'\n          });\n          if (this.ghostElementTemplate) {\n            const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n            clone.innerHTML = '';\n            viewRef.rootNodes.filter(node => node instanceof Node).forEach(node => {\n              clone.appendChild(node);\n            });\n            dragEnded$.subscribe(() => {\n              this.vcr.remove(this.vcr.indexOf(viewRef));\n            });\n          }\n          if (this.ghostElementCreated.observers.length > 0) {\n            this.zone.run(() => {\n              this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n          }\n          dragEnded$.subscribe(() => {\n            clone.parentElement.removeChild(clone);\n            this.ghostElement = null;\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n          });\n        }\n        this.draggableHelper.currentDrag.next(currentDrag$);\n      });\n      dragEnded$.pipe(mergeMap(dragEndData => {\n        const dragEndData$ = cancelDrag$.pipe(count(), take(1), map(calledCount => ({\n          ...dragEndData,\n          dragCancelled: calledCount > 0\n        })));\n        cancelDrag$.complete();\n        return dragEndData$;\n      })).subscribe(({\n        x,\n        y,\n        dragCancelled\n      }) => {\n        this.scroller.destroy();\n        if (this.dragEnd.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragEnd.next({\n              x,\n              y,\n              dragCancelled\n            });\n          });\n        }\n        removeClass(this.renderer, this.element, this.dragActiveClass);\n        currentDrag$.complete();\n      });\n      merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(() => {\n        requestAnimationFrame(() => {\n          this.document.head.removeChild(globalDragStyle);\n        });\n      });\n      return pointerMove;\n    }), share());\n    merge(pointerDragged$.pipe(take(1), map(value => [, value])), pointerDragged$.pipe(pairwise())).pipe(filter(([previous, next]) => {\n      if (!previous) {\n        return true;\n      }\n      return previous.x !== next.x || previous.y !== next.y;\n    }), map(([previous, next]) => next)).subscribe(({\n      x,\n      y,\n      currentDrag$,\n      clientX,\n      clientY,\n      transformX,\n      transformY,\n      target\n    }) => {\n      if (this.dragging.observers.length > 0) {\n        this.zone.run(() => {\n          this.dragging.next({\n            x,\n            y\n          });\n        });\n      }\n      requestAnimationFrame(() => {\n        if (this.ghostElement) {\n          const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n          this.setElementStyles(this.ghostElement, {\n            transform,\n            '-webkit-transform': transform,\n            '-ms-transform': transform,\n            '-moz-transform': transform,\n            '-o-transform': transform\n          });\n        }\n      });\n      currentDrag$.next({\n        clientX,\n        clientY,\n        dropData: this.dropData,\n        target\n      });\n    });\n  }\n  ngOnChanges(changes) {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n  ngOnDestroy() {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n  checkEventListeners() {\n    const canDrag = this.canDrag();\n    const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', event => {\n          this.onMouseDown(event);\n        });\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', event => {\n          this.onMouseUp(event);\n        });\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', event => {\n          this.onTouchStart(event);\n        });\n        this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', () => {\n          this.onMouseEnter();\n        });\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', () => {\n          this.onMouseLeave();\n        });\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n  onMouseDown(event) {\n    if (event.button === 0) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', mouseMoveEvent => {\n          this.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        });\n      }\n      this.pointerDown$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n  onMouseUp(event) {\n    if (event.button === 0) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n      this.pointerUp$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n  onTouchStart(event) {\n    let startScrollPosition;\n    let isDragActivated;\n    let hasContainerScrollbar;\n    if (this.touchStartLongPress) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n    if (!this.eventListenerSubscriptions.touchmove) {\n      const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(e => {\n        e.preventDefault();\n      });\n      const touchMoveListener = fromEvent(this.document, 'touchmove', {\n        passive: false\n      }).subscribe(touchMoveEvent => {\n        if (this.touchStartLongPress && !isDragActivated && hasContainerScrollbar) {\n          isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n        }\n        if (!this.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n          touchMoveEvent.preventDefault();\n          this.pointerMove$.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        }\n      });\n      this.eventListenerSubscriptions.touchmove = () => {\n        contextMenuListener.unsubscribe();\n        touchMoveListener.unsubscribe();\n      };\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n  onTouchEnd(event) {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n      if (this.touchStartLongPress) {\n        this.enableScroll();\n      }\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n  onMouseEnter() {\n    this.setCursor(this.dragCursor);\n  }\n  onMouseLeave() {\n    this.setCursor('');\n  }\n  canDrag() {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n  setCursor(value) {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n  }\n  unsubscribeEventListeners() {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      this.eventListenerSubscriptions[type]();\n      delete this.eventListenerSubscriptions[type];\n    });\n  }\n  setElementStyles(element, styles) {\n    Object.keys(styles).forEach(key => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n  getScrollElement() {\n    if (this.scrollContainer) {\n      return this.scrollContainer.elementRef.nativeElement;\n    } else {\n      return this.document.body;\n    }\n  }\n  getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n      };\n    } else {\n      return {\n        top: window.pageYOffset || this.document.documentElement.scrollTop,\n        left: window.pageXOffset || this.document.documentElement.scrollLeft\n      };\n    }\n  }\n  shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n    const moveScrollPosition = this.getScrollPosition();\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n    };\n    const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n    const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n    const deltaTotal = deltaX + deltaY;\n    const longPressConfig = this.touchStartLongPress;\n    if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n    this.timeLongPress.timerEnd = Date.now();\n    const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n    if (duration >= longPressConfig.delay) {\n      this.disableScroll();\n      return true;\n    }\n    return false;\n  }\n  enableScroll() {\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n    }\n    this.renderer.setStyle(this.document.body, 'overflow', '');\n  }\n  disableScroll() {\n    /* istanbul ignore next */\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n    }\n    this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n  }\n  hasScrollbar() {\n    const scrollContainer = this.getScrollElement();\n    const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n    const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n}\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DraggableHelper), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), i0.ɵɵdirectiveInject(DOCUMENT));\n};\nDraggableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dropData: \"dropData\",\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n    validateDrag: \"validateDrag\",\n    dragCursor: \"dragCursor\",\n    dragActiveClass: \"dragActiveClass\",\n    ghostElementAppendTo: \"ghostElementAppendTo\",\n    ghostElementTemplate: \"ghostElementTemplate\",\n    touchStartLongPress: \"touchStartLongPress\",\n    autoScroll: \"autoScroll\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    ghostElementCreated: \"ghostElementCreated\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    dropData: [{\n      type: Input\n    }],\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    showOriginalElementWhileDragging: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    ghostElementAppendTo: [{\n      type: Input\n    }],\n    ghostElementTemplate: [{\n      type: Input\n    }],\n    touchStartLongPress: [{\n      type: Input\n    }],\n    autoScroll: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    ghostElementCreated: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }]\n  });\n})();\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\nclass DroppableDirective {\n  constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.renderer = renderer;\n    this.scrollContainer = scrollContainer;\n    /**\n     * Called when a draggable element starts overlapping the element\n     */\n    this.dragEnter = new EventEmitter();\n    /**\n     * Called when a draggable element stops overlapping the element\n     */\n    this.dragLeave = new EventEmitter();\n    /**\n     * Called when a draggable element is moved over the element\n     */\n    this.dragOver = new EventEmitter();\n    /**\n     * Called when a draggable element is dropped on this element\n     */\n    this.drop = new EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native\n  }\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(drag$ => {\n      addClass(this.renderer, this.element, this.dragActiveClass);\n      const droppableElement = {\n        updateCache: true\n      };\n      const deregisterScrollListener = this.renderer.listen(this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window', 'scroll', () => {\n        droppableElement.updateCache = true;\n      });\n      let currentDragEvent;\n      const overlaps$ = drag$.pipe(map(({\n        clientX,\n        clientY,\n        dropData,\n        target\n      }) => {\n        currentDragEvent = {\n          clientX,\n          clientY,\n          dropData,\n          target\n        };\n        if (droppableElement.updateCache) {\n          droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n          if (this.scrollContainer) {\n            droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n          }\n          droppableElement.updateCache = false;\n        }\n        const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n        const isDropAllowed = !this.validateDrop || this.validateDrop({\n          clientX,\n          clientY,\n          target,\n          dropData\n        });\n        if (droppableElement.scrollContainerRect) {\n          return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect);\n        } else {\n          return isWithinElement && isDropAllowed;\n        }\n      }));\n      const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n      let dragOverActive; // TODO - see if there's a way of doing this via rxjs\n      overlapsChanged$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n        dragOverActive = true;\n        addClass(this.renderer, this.element, this.dragOverClass);\n        if (this.dragEnter.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragEnter.next(currentDragEvent);\n          });\n        }\n      });\n      overlaps$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n        if (this.dragOver.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragOver.next(currentDragEvent);\n          });\n        }\n      });\n      overlapsChanged$.pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)).subscribe(() => {\n        dragOverActive = false;\n        removeClass(this.renderer, this.element, this.dragOverClass);\n        if (this.dragLeave.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragLeave.next(currentDragEvent);\n          });\n        }\n      });\n      drag$.subscribe({\n        complete: () => {\n          deregisterScrollListener();\n          removeClass(this.renderer, this.element, this.dragActiveClass);\n          if (dragOverActive) {\n            removeClass(this.renderer, this.element, this.dragOverClass);\n            if (this.drop.observers.length > 0) {\n              this.zone.run(() => {\n                this.drop.next(currentDragEvent);\n              });\n            }\n          }\n        }\n      });\n    });\n  }\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n}\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DraggableHelper), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n};\nDroppableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  inputs: {\n    dragOverClass: \"dragOverClass\",\n    dragActiveClass: \"dragActiveClass\",\n    validateDrop: \"validateDrop\"\n  },\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    dragOverClass: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    validateDrop: [{\n      type: Input\n    }],\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }]\n  });\n})();\nclass DragAndDropModule {}\nDragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {\n  return new (t || DragAndDropModule)();\n};\nDragAndDropModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of angular-draggable-droppable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DragAndDropModule, DraggableDirective, DraggableScrollContainerDirective, DroppableDirective };","map":{"version":3,"names":["i0","Injectable","Directive","EventEmitter","Optional","Inject","Input","Output","NgModule","Subject","Observable","ReplaySubject","merge","combineLatest","fromEvent","filter","mergeMap","startWith","map","share","takeUntil","take","takeLast","count","pairwise","distinctUntilChanged","DOCUMENT","autoScroll","addClass","renderer","element","classToAdd","split","forEach","className","nativeElement","removeClass","classToRemove","DraggableHelper","constructor","currentDrag","ɵfac","ɵprov","type","args","providedIn","DraggableScrollContainerDirective","elementRef","ElementRef","ɵdir","selector","DraggableDirective","draggableHelper","zone","vcr","scrollContainer","document","dragAxis","x","y","dragSnapGrid","ghostDragEnabled","showOriginalElementWhileDragging","dragCursor","margin","dragPointerDown","dragStart","ghostElementCreated","dragging","dragEnd","pointerDown$","pointerMove$","pointerUp$","eventListenerSubscriptions","destroy$","timeLongPress","timerBegin","timerEnd","ngOnInit","checkEventListeners","pointerDragged$","pipe","canDrag","pointerDownEvent","event","stopPropagation","globalDragStyle","createElement","setAttribute","appendChild","createText","requestAnimationFrame","head","startScrollPosition","getScrollPosition","scrollContainerScroll$","observer","listen","e","next","currentDrag$","cancelDrag$","observers","length","run","dragComplete$","pointerMove","pointerMoveEvent","scroll","transformX","clientX","transformY","clientY","scrollLeft","left","scrollTop","top","target","moveData","Math","round","scrollX","scrollY","validateDrag","transform","dragStarted$","dragEnded$","subscribe","scroller","defaultView","dragActiveClass","rect","getBoundingClientRect","clone","cloneNode","setStyle","ghostElementAppendTo","parentNode","insertBefore","nextSibling","ghostElement","body","style","cursor","setElementStyles","position","width","height","willChange","pointerEvents","ghostElementTemplate","viewRef","createEmbeddedView","innerHTML","rootNodes","node","Node","remove","indexOf","emit","parentElement","removeChild","dragEndData","dragEndData$","calledCount","dragCancelled","complete","destroy","value","previous","dropData","ngOnChanges","changes","ngOnDestroy","unsubscribeEventListeners","hasEventListeners","Object","keys","runOutsideAngular","mousedown","onMouseDown","mouseup","onMouseUp","touchstart","onTouchStart","touchend","onTouchEnd","touchcancel","mouseenter","onMouseEnter","mouseleave","onMouseLeave","button","mousemove","mouseMoveEvent","isDragActivated","hasContainerScrollbar","touchStartLongPress","Date","now","hasScrollbar","touchmove","contextMenuListener","preventDefault","touchMoveListener","passive","touchMoveEvent","shouldBeginDrag","targetTouches","unsubscribe","touches","enableScroll","changedTouches","setCursor","styles","key","getScrollElement","window","pageYOffset","documentElement","pageXOffset","moveScrollPosition","deltaScroll","abs","deltaX","deltaY","deltaTotal","longPressConfig","delta","duration","delay","disableScroll","containerHasHorizontalScroll","scrollWidth","clientWidth","containerHasVerticalScroll","scrollHeight","clientHeight","Renderer2","NgZone","ViewContainerRef","decorators","undefined","isCoordinateWithinRectangle","right","bottom","DroppableDirective","dragEnter","dragLeave","dragOver","drop","currentDragSubscription","drag$","droppableElement","updateCache","deregisterScrollListener","currentDragEvent","overlaps$","scrollContainerRect","isWithinElement","isDropAllowed","validateDrop","overlapsChanged$","dragOverActive","overlapsNow","dragOverClass","didOverlap","DragAndDropModule","ɵmod","ɵinj","declarations","exports"],"sources":["F:/Plantillas/template/node_modules/angular-draggable-droppable/fesm2020/angular-draggable-droppable.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Directive, EventEmitter, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { Subject, Observable, ReplaySubject, merge, combineLatest, fromEvent } from 'rxjs';\nimport { filter, mergeMap, startWith, map, share, takeUntil, take, takeLast, count, pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\n\nfunction addClass(renderer, element, classToAdd) {\n    if (classToAdd) {\n        classToAdd\n            .split(' ')\n            .forEach((className) => renderer.addClass(element.nativeElement, className));\n    }\n}\nfunction removeClass(renderer, element, classToRemove) {\n    if (classToRemove) {\n        classToRemove\n            .split(' ')\n            .forEach((className) => renderer.removeClass(element.nativeElement, className));\n    }\n}\n\nclass DraggableHelper {\n    constructor() {\n        this.currentDrag = new Subject();\n    }\n}\nDraggableHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableHelper, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDraggableHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableHelper, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableHelper, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\nclass DraggableScrollContainerDirective {\n    /**\n     * @hidden\n     */\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n    }\n}\nDraggableScrollContainerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableScrollContainerDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\nDraggableScrollContainerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.1.0\", type: DraggableScrollContainerDirective, selector: \"[mwlDraggableScrollContainer]\", ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableScrollContainerDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDraggableScrollContainer]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\nclass DraggableDirective {\n    /**\n     * @hidden\n     */\n    constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n        this.element = element;\n        this.renderer = renderer;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.vcr = vcr;\n        this.scrollContainer = scrollContainer;\n        this.document = document;\n        /**\n         * The axis along which the element is draggable\n         */\n        this.dragAxis = { x: true, y: true };\n        /**\n         * Snap all drags to an x / y grid\n         */\n        this.dragSnapGrid = {};\n        /**\n         * Show a ghost element that shows the drag when dragging\n         */\n        this.ghostDragEnabled = true;\n        /**\n         * Show the original element when ghostDragEnabled is true\n         */\n        this.showOriginalElementWhileDragging = false;\n        /**\n         * The cursor to use when hovering over a draggable element\n         */\n        this.dragCursor = '';\n        /*\n         * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n         */\n        this.autoScroll = {\n            margin: 20,\n        };\n        /**\n         * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n         */\n        this.dragPointerDown = new EventEmitter();\n        /**\n         * Called when the element has started to be dragged.\n         * Only called after at least one mouse or touch move event.\n         * If you call $event.cancelDrag$.emit() it will cancel the current drag\n         */\n        this.dragStart = new EventEmitter();\n        /**\n         * Called after the ghost element has been created\n         */\n        this.ghostElementCreated = new EventEmitter();\n        /**\n         * Called when the element is being dragged\n         */\n        this.dragging = new EventEmitter();\n        /**\n         * Called after the element is dragged\n         */\n        this.dragEnd = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.pointerDown$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerMove$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerUp$ = new Subject();\n        this.eventListenerSubscriptions = {};\n        this.destroy$ = new Subject();\n        this.timeLongPress = { timerBegin: 0, timerEnd: 0 };\n    }\n    ngOnInit() {\n        this.checkEventListeners();\n        const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap((pointerDownEvent) => {\n            // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n            // stop mouse events propagating up the chain\n            if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n                pointerDownEvent.event.stopPropagation();\n            }\n            // hack to prevent text getting selected in safari while dragging\n            const globalDragStyle = this.renderer.createElement('style');\n            this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n            this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n            requestAnimationFrame(() => {\n                this.document.head.appendChild(globalDragStyle);\n            });\n            const startScrollPosition = this.getScrollPosition();\n            const scrollContainerScroll$ = new Observable((observer) => {\n                const scrollContainer = this.scrollContainer\n                    ? this.scrollContainer.elementRef.nativeElement\n                    : 'window';\n                return this.renderer.listen(scrollContainer, 'scroll', (e) => observer.next(e));\n            }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));\n            const currentDrag$ = new Subject();\n            const cancelDrag$ = new ReplaySubject();\n            if (this.dragPointerDown.observers.length > 0) {\n                this.zone.run(() => {\n                    this.dragPointerDown.next({ x: 0, y: 0 });\n                });\n            }\n            const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n            const pointerMove = combineLatest([\n                this.pointerMove$,\n                scrollContainerScroll$,\n            ]).pipe(map(([pointerMoveEvent, scroll]) => {\n                return {\n                    currentDrag$,\n                    transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n                    transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n                    clientX: pointerMoveEvent.clientX,\n                    clientY: pointerMoveEvent.clientY,\n                    scrollLeft: scroll.left,\n                    scrollTop: scroll.top,\n                    target: pointerMoveEvent.event.target,\n                };\n            }), map((moveData) => {\n                if (this.dragSnapGrid.x) {\n                    moveData.transformX =\n                        Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                            this.dragSnapGrid.x;\n                }\n                if (this.dragSnapGrid.y) {\n                    moveData.transformY =\n                        Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                            this.dragSnapGrid.y;\n                }\n                return moveData;\n            }), map((moveData) => {\n                if (!this.dragAxis.x) {\n                    moveData.transformX = 0;\n                }\n                if (!this.dragAxis.y) {\n                    moveData.transformY = 0;\n                }\n                return moveData;\n            }), map((moveData) => {\n                const scrollX = moveData.scrollLeft - startScrollPosition.left;\n                const scrollY = moveData.scrollTop - startScrollPosition.top;\n                return {\n                    ...moveData,\n                    x: moveData.transformX + scrollX,\n                    y: moveData.transformY + scrollY,\n                };\n            }), filter(({ x, y, transformX, transformY }) => !this.validateDrag ||\n                this.validateDrag({\n                    x,\n                    y,\n                    transform: { x: transformX, y: transformY },\n                })), takeUntil(dragComplete$), share());\n            const dragStarted$ = pointerMove.pipe(take(1), share());\n            const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n            dragStarted$.subscribe(({ clientX, clientY, x, y }) => {\n                if (this.dragStart.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragStart.next({ cancelDrag$ });\n                    });\n                }\n                this.scroller = autoScroll([\n                    this.scrollContainer\n                        ? this.scrollContainer.elementRef.nativeElement\n                        : this.document.defaultView,\n                ], {\n                    ...this.autoScroll,\n                    autoScroll() {\n                        return true;\n                    },\n                });\n                addClass(this.renderer, this.element, this.dragActiveClass);\n                if (this.ghostDragEnabled) {\n                    const rect = this.element.nativeElement.getBoundingClientRect();\n                    const clone = this.element.nativeElement.cloneNode(true);\n                    if (!this.showOriginalElementWhileDragging) {\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n                    }\n                    if (this.ghostElementAppendTo) {\n                        this.ghostElementAppendTo.appendChild(clone);\n                    }\n                    else {\n                        this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n                    }\n                    this.ghostElement = clone;\n                    this.document.body.style.cursor = this.dragCursor;\n                    this.setElementStyles(clone, {\n                        position: 'fixed',\n                        top: `${rect.top}px`,\n                        left: `${rect.left}px`,\n                        width: `${rect.width}px`,\n                        height: `${rect.height}px`,\n                        cursor: this.dragCursor,\n                        margin: '0',\n                        willChange: 'transform',\n                        pointerEvents: 'none',\n                    });\n                    if (this.ghostElementTemplate) {\n                        const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n                        clone.innerHTML = '';\n                        viewRef.rootNodes\n                            .filter((node) => node instanceof Node)\n                            .forEach((node) => {\n                            clone.appendChild(node);\n                        });\n                        dragEnded$.subscribe(() => {\n                            this.vcr.remove(this.vcr.indexOf(viewRef));\n                        });\n                    }\n                    if (this.ghostElementCreated.observers.length > 0) {\n                        this.zone.run(() => {\n                            this.ghostElementCreated.emit({\n                                clientX: clientX - x,\n                                clientY: clientY - y,\n                                element: clone,\n                            });\n                        });\n                    }\n                    dragEnded$.subscribe(() => {\n                        clone.parentElement.removeChild(clone);\n                        this.ghostElement = null;\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n                    });\n                }\n                this.draggableHelper.currentDrag.next(currentDrag$);\n            });\n            dragEnded$\n                .pipe(mergeMap((dragEndData) => {\n                const dragEndData$ = cancelDrag$.pipe(count(), take(1), map((calledCount) => ({\n                    ...dragEndData,\n                    dragCancelled: calledCount > 0,\n                })));\n                cancelDrag$.complete();\n                return dragEndData$;\n            }))\n                .subscribe(({ x, y, dragCancelled }) => {\n                this.scroller.destroy();\n                if (this.dragEnd.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragEnd.next({ x, y, dragCancelled });\n                    });\n                }\n                removeClass(this.renderer, this.element, this.dragActiveClass);\n                currentDrag$.complete();\n            });\n            merge(dragComplete$, dragEnded$)\n                .pipe(take(1))\n                .subscribe(() => {\n                requestAnimationFrame(() => {\n                    this.document.head.removeChild(globalDragStyle);\n                });\n            });\n            return pointerMove;\n        }), share());\n        merge(pointerDragged$.pipe(take(1), map((value) => [, value])), pointerDragged$.pipe(pairwise()))\n            .pipe(filter(([previous, next]) => {\n            if (!previous) {\n                return true;\n            }\n            return previous.x !== next.x || previous.y !== next.y;\n        }), map(([previous, next]) => next))\n            .subscribe(({ x, y, currentDrag$, clientX, clientY, transformX, transformY, target, }) => {\n            if (this.dragging.observers.length > 0) {\n                this.zone.run(() => {\n                    this.dragging.next({ x, y });\n                });\n            }\n            requestAnimationFrame(() => {\n                if (this.ghostElement) {\n                    const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n                    this.setElementStyles(this.ghostElement, {\n                        transform,\n                        '-webkit-transform': transform,\n                        '-ms-transform': transform,\n                        '-moz-transform': transform,\n                        '-o-transform': transform,\n                    });\n                }\n            });\n            currentDrag$.next({\n                clientX,\n                clientY,\n                dropData: this.dropData,\n                target,\n            });\n        });\n    }\n    ngOnChanges(changes) {\n        if (changes.dragAxis) {\n            this.checkEventListeners();\n        }\n    }\n    ngOnDestroy() {\n        this.unsubscribeEventListeners();\n        this.pointerDown$.complete();\n        this.pointerMove$.complete();\n        this.pointerUp$.complete();\n        this.destroy$.next();\n    }\n    checkEventListeners() {\n        const canDrag = this.canDrag();\n        const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n        if (canDrag && !hasEventListeners) {\n            this.zone.runOutsideAngular(() => {\n                this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', (event) => {\n                    this.onMouseDown(event);\n                });\n                this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', (event) => {\n                    this.onMouseUp(event);\n                });\n                this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', (event) => {\n                    this.onTouchStart(event);\n                });\n                this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', (event) => {\n                    this.onTouchEnd(event);\n                });\n                this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', (event) => {\n                    this.onTouchEnd(event);\n                });\n                this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', () => {\n                    this.onMouseEnter();\n                });\n                this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', () => {\n                    this.onMouseLeave();\n                });\n            });\n        }\n        else if (!canDrag && hasEventListeners) {\n            this.unsubscribeEventListeners();\n        }\n    }\n    onMouseDown(event) {\n        if (event.button === 0) {\n            if (!this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', (mouseMoveEvent) => {\n                    this.pointerMove$.next({\n                        event: mouseMoveEvent,\n                        clientX: mouseMoveEvent.clientX,\n                        clientY: mouseMoveEvent.clientY,\n                    });\n                });\n            }\n            this.pointerDown$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    onMouseUp(event) {\n        if (event.button === 0) {\n            if (this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove();\n                delete this.eventListenerSubscriptions.mousemove;\n            }\n            this.pointerUp$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    onTouchStart(event) {\n        let startScrollPosition;\n        let isDragActivated;\n        let hasContainerScrollbar;\n        if (this.touchStartLongPress) {\n            this.timeLongPress.timerBegin = Date.now();\n            isDragActivated = false;\n            hasContainerScrollbar = this.hasScrollbar();\n            startScrollPosition = this.getScrollPosition();\n        }\n        if (!this.eventListenerSubscriptions.touchmove) {\n            const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe((e) => {\n                e.preventDefault();\n            });\n            const touchMoveListener = fromEvent(this.document, 'touchmove', {\n                passive: false,\n            }).subscribe((touchMoveEvent) => {\n                if (this.touchStartLongPress &&\n                    !isDragActivated &&\n                    hasContainerScrollbar) {\n                    isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n                }\n                if (!this.touchStartLongPress ||\n                    !hasContainerScrollbar ||\n                    isDragActivated) {\n                    touchMoveEvent.preventDefault();\n                    this.pointerMove$.next({\n                        event: touchMoveEvent,\n                        clientX: touchMoveEvent.targetTouches[0].clientX,\n                        clientY: touchMoveEvent.targetTouches[0].clientY,\n                    });\n                }\n            });\n            this.eventListenerSubscriptions.touchmove = () => {\n                contextMenuListener.unsubscribe();\n                touchMoveListener.unsubscribe();\n            };\n        }\n        this.pointerDown$.next({\n            event,\n            clientX: event.touches[0].clientX,\n            clientY: event.touches[0].clientY,\n        });\n    }\n    onTouchEnd(event) {\n        if (this.eventListenerSubscriptions.touchmove) {\n            this.eventListenerSubscriptions.touchmove();\n            delete this.eventListenerSubscriptions.touchmove;\n            if (this.touchStartLongPress) {\n                this.enableScroll();\n            }\n        }\n        this.pointerUp$.next({\n            event,\n            clientX: event.changedTouches[0].clientX,\n            clientY: event.changedTouches[0].clientY,\n        });\n    }\n    onMouseEnter() {\n        this.setCursor(this.dragCursor);\n    }\n    onMouseLeave() {\n        this.setCursor('');\n    }\n    canDrag() {\n        return this.dragAxis.x || this.dragAxis.y;\n    }\n    setCursor(value) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n            this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n        }\n    }\n    unsubscribeEventListeners() {\n        Object.keys(this.eventListenerSubscriptions).forEach((type) => {\n            this.eventListenerSubscriptions[type]();\n            delete this.eventListenerSubscriptions[type];\n        });\n    }\n    setElementStyles(element, styles) {\n        Object.keys(styles).forEach((key) => {\n            this.renderer.setStyle(element, key, styles[key]);\n        });\n    }\n    getScrollElement() {\n        if (this.scrollContainer) {\n            return this.scrollContainer.elementRef.nativeElement;\n        }\n        else {\n            return this.document.body;\n        }\n    }\n    getScrollPosition() {\n        if (this.scrollContainer) {\n            return {\n                top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n                left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n            };\n        }\n        else {\n            return {\n                top: window.pageYOffset || this.document.documentElement.scrollTop,\n                left: window.pageXOffset || this.document.documentElement.scrollLeft,\n            };\n        }\n    }\n    shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n        const moveScrollPosition = this.getScrollPosition();\n        const deltaScroll = {\n            top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n            left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n        };\n        const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n        const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n        const deltaTotal = deltaX + deltaY;\n        const longPressConfig = this.touchStartLongPress;\n        if (deltaTotal > longPressConfig.delta ||\n            deltaScroll.top > 0 ||\n            deltaScroll.left > 0) {\n            this.timeLongPress.timerBegin = Date.now();\n        }\n        this.timeLongPress.timerEnd = Date.now();\n        const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n        if (duration >= longPressConfig.delay) {\n            this.disableScroll();\n            return true;\n        }\n        return false;\n    }\n    enableScroll() {\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', '');\n    }\n    disableScroll() {\n        /* istanbul ignore next */\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    }\n    hasScrollbar() {\n        const scrollContainer = this.getScrollElement();\n        const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n        const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n        return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n}\nDraggableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: DraggableHelper }, { token: i0.NgZone }, { token: i0.ViewContainerRef }, { token: DraggableScrollContainerDirective, optional: true }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });\nDraggableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.1.0\", type: DraggableDirective, selector: \"[mwlDraggable]\", inputs: { dropData: \"dropData\", dragAxis: \"dragAxis\", dragSnapGrid: \"dragSnapGrid\", ghostDragEnabled: \"ghostDragEnabled\", showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\", validateDrag: \"validateDrag\", dragCursor: \"dragCursor\", dragActiveClass: \"dragActiveClass\", ghostElementAppendTo: \"ghostElementAppendTo\", ghostElementTemplate: \"ghostElementTemplate\", touchStartLongPress: \"touchStartLongPress\", autoScroll: \"autoScroll\" }, outputs: { dragPointerDown: \"dragPointerDown\", dragStart: \"dragStart\", ghostElementCreated: \"ghostElementCreated\", dragging: \"dragging\", dragEnd: \"dragEnd\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDraggable]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DraggableHelper }, { type: i0.NgZone }, { type: i0.ViewContainerRef }, { type: DraggableScrollContainerDirective, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }]; }, propDecorators: { dropData: [{\n                type: Input\n            }], dragAxis: [{\n                type: Input\n            }], dragSnapGrid: [{\n                type: Input\n            }], ghostDragEnabled: [{\n                type: Input\n            }], showOriginalElementWhileDragging: [{\n                type: Input\n            }], validateDrag: [{\n                type: Input\n            }], dragCursor: [{\n                type: Input\n            }], dragActiveClass: [{\n                type: Input\n            }], ghostElementAppendTo: [{\n                type: Input\n            }], ghostElementTemplate: [{\n                type: Input\n            }], touchStartLongPress: [{\n                type: Input\n            }], autoScroll: [{\n                type: Input\n            }], dragPointerDown: [{\n                type: Output\n            }], dragStart: [{\n                type: Output\n            }], ghostElementCreated: [{\n                type: Output\n            }], dragging: [{\n                type: Output\n            }], dragEnd: [{\n                type: Output\n            }] } });\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n    return (clientX >= rect.left &&\n        clientX <= rect.right &&\n        clientY >= rect.top &&\n        clientY <= rect.bottom);\n}\nclass DroppableDirective {\n    constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n        this.element = element;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.scrollContainer = scrollContainer;\n        /**\n         * Called when a draggable element starts overlapping the element\n         */\n        this.dragEnter = new EventEmitter();\n        /**\n         * Called when a draggable element stops overlapping the element\n         */\n        this.dragLeave = new EventEmitter();\n        /**\n         * Called when a draggable element is moved over the element\n         */\n        this.dragOver = new EventEmitter();\n        /**\n         * Called when a draggable element is dropped on this element\n         */\n        this.drop = new EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native\n    }\n    ngOnInit() {\n        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((drag$) => {\n            addClass(this.renderer, this.element, this.dragActiveClass);\n            const droppableElement = {\n                updateCache: true,\n            };\n            const deregisterScrollListener = this.renderer.listen(this.scrollContainer\n                ? this.scrollContainer.elementRef.nativeElement\n                : 'window', 'scroll', () => {\n                droppableElement.updateCache = true;\n            });\n            let currentDragEvent;\n            const overlaps$ = drag$.pipe(map(({ clientX, clientY, dropData, target }) => {\n                currentDragEvent = { clientX, clientY, dropData, target };\n                if (droppableElement.updateCache) {\n                    droppableElement.rect =\n                        this.element.nativeElement.getBoundingClientRect();\n                    if (this.scrollContainer) {\n                        droppableElement.scrollContainerRect =\n                            this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n                    }\n                    droppableElement.updateCache = false;\n                }\n                const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n                const isDropAllowed = !this.validateDrop ||\n                    this.validateDrop({ clientX, clientY, target, dropData });\n                if (droppableElement.scrollContainerRect) {\n                    return (isWithinElement &&\n                        isDropAllowed &&\n                        isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect));\n                }\n                else {\n                    return isWithinElement && isDropAllowed;\n                }\n            }));\n            const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n            let dragOverActive; // TODO - see if there's a way of doing this via rxjs\n            overlapsChanged$\n                .pipe(filter((overlapsNow) => overlapsNow))\n                .subscribe(() => {\n                dragOverActive = true;\n                addClass(this.renderer, this.element, this.dragOverClass);\n                if (this.dragEnter.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragEnter.next(currentDragEvent);\n                    });\n                }\n            });\n            overlaps$.pipe(filter((overlapsNow) => overlapsNow)).subscribe(() => {\n                if (this.dragOver.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragOver.next(currentDragEvent);\n                    });\n                }\n            });\n            overlapsChanged$\n                .pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow))\n                .subscribe(() => {\n                dragOverActive = false;\n                removeClass(this.renderer, this.element, this.dragOverClass);\n                if (this.dragLeave.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragLeave.next(currentDragEvent);\n                    });\n                }\n            });\n            drag$.subscribe({\n                complete: () => {\n                    deregisterScrollListener();\n                    removeClass(this.renderer, this.element, this.dragActiveClass);\n                    if (dragOverActive) {\n                        removeClass(this.renderer, this.element, this.dragOverClass);\n                        if (this.drop.observers.length > 0) {\n                            this.zone.run(() => {\n                                this.drop.next(currentDragEvent);\n                            });\n                        }\n                    }\n                },\n            });\n        });\n    }\n    ngOnDestroy() {\n        if (this.currentDragSubscription) {\n            this.currentDragSubscription.unsubscribe();\n        }\n    }\n}\nDroppableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DroppableDirective, deps: [{ token: i0.ElementRef }, { token: DraggableHelper }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: DraggableScrollContainerDirective, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\nDroppableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.1.0\", type: DroppableDirective, selector: \"[mwlDroppable]\", inputs: { dragOverClass: \"dragOverClass\", dragActiveClass: \"dragActiveClass\", validateDrop: \"validateDrop\" }, outputs: { dragEnter: \"dragEnter\", dragLeave: \"dragLeave\", dragOver: \"dragOver\", drop: \"drop\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DroppableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDroppable]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DraggableHelper }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: DraggableScrollContainerDirective, decorators: [{\n                    type: Optional\n                }] }]; }, propDecorators: { dragOverClass: [{\n                type: Input\n            }], dragActiveClass: [{\n                type: Input\n            }], validateDrop: [{\n                type: Input\n            }], dragEnter: [{\n                type: Output\n            }], dragLeave: [{\n                type: Output\n            }], dragOver: [{\n                type: Output\n            }], drop: [{\n                type: Output\n            }] } });\n\nclass DragAndDropModule {\n}\nDragAndDropModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DragAndDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nDragAndDropModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.1.0\", ngImport: i0, type: DragAndDropModule, declarations: [DraggableDirective,\n        DroppableDirective,\n        DraggableScrollContainerDirective], exports: [DraggableDirective,\n        DroppableDirective,\n        DraggableScrollContainerDirective] });\nDragAndDropModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DragAndDropModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DragAndDropModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                    exports: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                }]\n        }] });\n\n/*\n * Public API Surface of angular-draggable-droppable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DragAndDropModule, DraggableDirective, DraggableScrollContainerDirective, DroppableDirective };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}