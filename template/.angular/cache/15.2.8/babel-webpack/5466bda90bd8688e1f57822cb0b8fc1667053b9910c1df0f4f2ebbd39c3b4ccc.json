{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n  return function (source) {\n    return source.lift(new SwitchFirstMapOperator(project, resultSelector));\n  };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = function () {\n  function SwitchFirstMapOperator(project, resultSelector) {\n    this.project = project;\n    this.resultSelector = resultSelector;\n  }\n  SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n  };\n  return SwitchFirstMapOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = function (_super) {\n  __extends(SwitchFirstMapSubscriber, _super);\n  function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n    _super.call(this, destination);\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.hasSubscription = false;\n    this.hasCompleted = false;\n    this.index = 0;\n  }\n  SwitchFirstMapSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  };\n  SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n    var index = this.index++;\n    var destination = this.destination;\n    try {\n      var result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n  SwitchFirstMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n  SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n      resultSelector = _a.resultSelector,\n      destination = _a.destination;\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  };\n  SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var _a = this,\n      resultSelector = _a.resultSelector,\n      destination = _a.destination;\n    try {\n      var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n      destination.next(result);\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n  SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n  SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n  return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","OuterSubscriber_1","require","subscribeToResult_1","exhaustMap","project","resultSelector","source","lift","SwitchFirstMapOperator","exports","call","subscriber","subscribe","SwitchFirstMapSubscriber","_super","destination","hasSubscription","hasCompleted","index","_next","value","tryNext","result","add","subscribeToResult","err","error","_complete","complete","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","_a","trySelectResult","next","notifyError","notifyComplete","remove","OuterSubscriber"],"sources":["F:/Plantillas/template/node_modules/ng5-slider/node_modules/rxjs/operators/exhaustMap.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}