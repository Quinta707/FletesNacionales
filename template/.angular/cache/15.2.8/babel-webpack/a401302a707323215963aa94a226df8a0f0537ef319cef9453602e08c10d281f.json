{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module watchdog/watchdog\n */\n\n/* globals window */\n\n/**\n * An abstract watchdog class that handles most of the error handling process and the state of the underlying component.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and how to use it.\n *\n * @private\n * @abstract\n */\nexport default class Watchdog {\n  /**\n   * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.\n   */\n  constructor(config) {\n    /**\n     * An array of crashes saved as an object with the following properties:\n     *\n     * * `message`: `String`,\n     * * `stack`: `String`,\n     * * `date`: `Number`,\n     * * `filename`: `String | undefined`,\n     * * `lineno`: `Number | undefined`,\n     * * `colno`: `Number | undefined`,\n     *\n     * @public\n     * @readonly\n     * @type {Array.<Object>}\n     */\n    this.crashes = [];\n\n    /**\n     * Specifies the state of the item watched by the watchdog. The state can be one of the following values:\n     *\n     * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.\n     * * `ready` &ndash; A state when the user can interact with the item.\n     * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`\n     * depending on how many and how frequent errors have been caught recently.\n     * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,\n     * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.\n     *\n     * @public\n     * @type {'initializing'|'ready'|'crashed'|'crashedPermanently'|'destroyed'}\n     */\n    this.state = 'initializing';\n\n    /**\n     * @protected\n     * @type {Number}\n     * @see module:watchdog/watchdog~WatchdogConfig\n     */\n    this._crashNumberLimit = typeof config.crashNumberLimit === 'number' ? config.crashNumberLimit : 3;\n\n    /**\n     * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular\n     * approaches like `sinon.useFakeTimers()` do not work well with error handling.\n     *\n     * @protected\n     */\n    this._now = Date.now;\n\n    /**\n     * @protected\n     * @type {Number}\n     * @see module:watchdog/watchdog~WatchdogConfig\n     */\n    this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === 'number' ? config.minimumNonErrorTimePeriod : 5000;\n\n    /**\n     * Checks if the event error comes from the underlying item and restarts the item.\n     *\n     * @private\n     * @type {Function}\n     */\n    this._boundErrorHandler = evt => {\n      // `evt.error` is exposed by EventError while `evt.reason` is available in PromiseRejectionEvent.\n      const error = evt.error || evt.reason;\n\n      // Note that `evt.reason` might be everything that is in the promise rejection.\n      // Similarly everything that is thrown lands in `evt.error`.\n      if (error instanceof Error) {\n        this._handleError(error, evt);\n      }\n    };\n\n    /**\n     * The creation method.\n     *\n     * @protected\n     * @member {Function} #_creator\n     * @see #setCreator\n     */\n\n    /**\n     * The destruction method.\n     *\n     * @protected\n     * @member {Function} #_destructor\n     * @see #setDestructor\n     */\n\n    /**\n     * The watched item.\n     *\n     * @abstract\n     * @protected\n     * @member {Object|undefined} #_item\n     */\n\n    /**\n     * The method responsible for restarting the watched item.\n     *\n     * @abstract\n     * @protected\n     * @method #_restart\n     */\n\n    /**\n     * Traverses the error context and the watched item to find out whether the error should\n     * be handled by the given item.\n     *\n     * @abstract\n     * @protected\n     * @method #_isErrorComingFromThisItem\n     * @param {module:utils/ckeditorerror~CKEditorError} error\n     */\n\n    /**\n     * A dictionary of event emitter listeners.\n     *\n     * @private\n     * @type {Object.<String,Array.<Function>>}\n     */\n    this._listeners = {};\n    if (!this._restart) {\n      throw new Error('The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' + 'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.');\n    }\n  }\n\n  /**\n   * Sets the function that is responsible for creating watched items.\n   *\n   * @param {Function} creator A callback responsible for creating an item. Returns a promise\n   * that is resolved when the item is created.\n   */\n  setCreator(creator) {\n    this._creator = creator;\n  }\n\n  /**\n   * Sets the function that is responsible for destroying watched items.\n   *\n   * @param {Function} destructor A callback that takes the item and returns the promise\n   * to the destroying process.\n   */\n  setDestructor(destructor) {\n    this._destructor = destructor;\n  }\n\n  /**\n   * Destroys the watchdog and releases the resources.\n   */\n  destroy() {\n    this._stopErrorHandling();\n    this._listeners = {};\n  }\n\n  /**\n   * Starts listening to a specific event name by registering a callback that will be executed\n   * whenever an event with a given name fires.\n   *\n   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n   *\n   * @param {String} eventName The event name.\n   * @param {Function} callback A callback which will be added to event listeners.\n   */\n  on(eventName, callback) {\n    if (!this._listeners[eventName]) {\n      this._listeners[eventName] = [];\n    }\n    this._listeners[eventName].push(callback);\n  }\n\n  /**\n   * Stops listening to the specified event name by removing the callback from event listeners.\n   *\n   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n   *\n   * @param {String} eventName The event name.\n   * @param {Function} callback A callback which will be removed from event listeners.\n   */\n  off(eventName, callback) {\n    this._listeners[eventName] = this._listeners[eventName].filter(cb => cb !== callback);\n  }\n\n  /**\n   * Fires an event with a given event name and arguments.\n   *\n   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n   *\n   * @protected\n   * @param {String} eventName The event name.\n   * @param  {...*} args Event arguments.\n   */\n  _fire(eventName, ...args) {\n    const callbacks = this._listeners[eventName] || [];\n    for (const callback of callbacks) {\n      callback.apply(this, [null, ...args]);\n    }\n  }\n\n  /**\n   * Starts error handling by attaching global error handlers.\n   *\n   * @protected\n   */\n  _startErrorHandling() {\n    window.addEventListener('error', this._boundErrorHandler);\n    window.addEventListener('unhandledrejection', this._boundErrorHandler);\n  }\n\n  /**\n   * Stops error handling by detaching global error handlers.\n   *\n   * @protected\n   */\n  _stopErrorHandling() {\n    window.removeEventListener('error', this._boundErrorHandler);\n    window.removeEventListener('unhandledrejection', this._boundErrorHandler);\n  }\n\n  /**\n   * Checks if an error comes from the watched item and restarts it.\n   * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.\n   *\n   * @private\n   * @fires error\n   * @param {Error} error Error.\n   * @param {ErrorEvent|PromiseRejectionEvent} evt An error event.\n   */\n  _handleError(error, evt) {\n    // @if CK_DEBUG // if ( error.is && error.is( 'CKEditorError' ) && error.context === undefined ) {\n    // @if CK_DEBUG // console.warn( 'The error is missing its context and Watchdog cannot restart the proper item.' );\n    // @if CK_DEBUG // }\n\n    if (this._shouldReactToError(error)) {\n      this.crashes.push({\n        message: error.message,\n        stack: error.stack,\n        // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events\n        filename: evt.filename,\n        lineno: evt.lineno,\n        colno: evt.colno,\n        date: this._now()\n      });\n      const causesRestart = this._shouldRestart();\n      this.state = 'crashed';\n      this._fire('stateChange');\n      this._fire('error', {\n        error,\n        causesRestart\n      });\n      if (causesRestart) {\n        this._restart();\n      } else {\n        this.state = 'crashedPermanently';\n        this._fire('stateChange');\n      }\n    }\n  }\n\n  /**\n   * Checks whether an error should be handled by the watchdog.\n   *\n   * @private\n   * @param {Error} error An error that was caught by the error handling process.\n   */\n  _shouldReactToError(error) {\n    return error.is && error.is('CKEditorError') && error.context !== undefined &&\n    // In some cases the watched item should not be restarted - e.g. during the item initialization.\n    // That's why the `null` was introduced as a correct error context which does cause restarting.\n    error.context !== null &&\n    // Do not react to errors if the watchdog is in states other than `ready`.\n    this.state === 'ready' && this._isErrorComingFromThisItem(error);\n  }\n\n  /**\n   * Checks if the watchdog should restart the underlying item.\n   *\n   * @private\n   */\n  _shouldRestart() {\n    if (this.crashes.length <= this._crashNumberLimit) {\n      return true;\n    }\n    const lastErrorTime = this.crashes[this.crashes.length - 1].date;\n    const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;\n    const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;\n    return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;\n  }\n\n  /**\n   * Fired when a new {@link module:utils/ckeditorerror~CKEditorError `CKEditorError`} error connected to the watchdog instance occurs\n   * and the watchdog will react to it.\n   *\n   * \twatchdog.on( 'error', ( evt, { error, causesRestart } ) => {\n   * \t\tconsole.log( 'An error occurred.' );\n   * \t} );\n   *\n   * @event error\n   */\n}\n\n/**\n * The watchdog plugin configuration.\n *\n * @typedef {Object} WatchdogConfig\n *\n * @property {Number} [crashNumberLimit=3] A threshold specifying the number of watched item crashes\n * when the watchdog stops restarting the item in case of errors.\n * After this limit is reached and the time between the last errors is shorter than `minimumNonErrorTimePeriod`,\n * the watchdog changes its state to `crashedPermanently` and it stops restarting the item. This prevents an infinite restart loop.\n *\n * @property {Number} [minimumNonErrorTimePeriod=5000] An average number of milliseconds between the last watched item errors\n * (defaults to 5000). When the period of time between errors is lower than that and the `crashNumberLimit` is also reached,\n * the watchdog changes its state to `crashedPermanently` and it stops restarting the item. This prevents an infinite restart loop.\n *\n * @property {Number} [saveInterval=5000] A minimum number of milliseconds between saving the editor data internally (defaults to 5000).\n * Note that for large documents this might impact the editor performance.\n */","map":{"version":3,"names":["Watchdog","constructor","config","crashes","state","_crashNumberLimit","crashNumberLimit","_now","Date","now","_minimumNonErrorTimePeriod","minimumNonErrorTimePeriod","_boundErrorHandler","evt","error","reason","Error","_handleError","_listeners","_restart","setCreator","creator","_creator","setDestructor","destructor","_destructor","destroy","_stopErrorHandling","on","eventName","callback","push","off","filter","cb","_fire","args","callbacks","apply","_startErrorHandling","window","addEventListener","removeEventListener","_shouldReactToError","message","stack","filename","lineno","colno","date","causesRestart","_shouldRestart","is","context","undefined","_isErrorComingFromThisItem","length","lastErrorTime","firstMeaningfulErrorTime","averageNonErrorTimePeriod"],"sources":["C:/Users/Sarai Quintanilla/Documents/GitHub/FletesNacionales/template/node_modules/@ckeditor/ckeditor5-watchdog/src/watchdog.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module watchdog/watchdog\n */\n\n/* globals window */\n\n/**\n * An abstract watchdog class that handles most of the error handling process and the state of the underlying component.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and how to use it.\n *\n * @private\n * @abstract\n */\nexport default class Watchdog {\n\t/**\n\t * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.\n\t */\n\tconstructor( config ) {\n\t\t/**\n\t\t * An array of crashes saved as an object with the following properties:\n\t\t *\n\t\t * * `message`: `String`,\n\t\t * * `stack`: `String`,\n\t\t * * `date`: `Number`,\n\t\t * * `filename`: `String | undefined`,\n\t\t * * `lineno`: `Number | undefined`,\n\t\t * * `colno`: `Number | undefined`,\n\t\t *\n\t\t * @public\n\t\t * @readonly\n\t\t * @type {Array.<Object>}\n\t\t */\n\t\tthis.crashes = [];\n\n\t\t/**\n\t\t * Specifies the state of the item watched by the watchdog. The state can be one of the following values:\n\t\t *\n\t\t * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.\n\t\t * * `ready` &ndash; A state when the user can interact with the item.\n\t\t * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`\n\t\t * depending on how many and how frequent errors have been caught recently.\n\t\t * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,\n\t\t * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.\n\t\t *\n\t\t * @public\n\t\t * @type {'initializing'|'ready'|'crashed'|'crashedPermanently'|'destroyed'}\n\t\t */\n\t\tthis.state = 'initializing';\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @see module:watchdog/watchdog~WatchdogConfig\n\t\t */\n\t\tthis._crashNumberLimit = typeof config.crashNumberLimit === 'number' ? config.crashNumberLimit : 3;\n\n\t\t/**\n\t\t * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular\n\t\t * approaches like `sinon.useFakeTimers()` do not work well with error handling.\n\t\t *\n\t\t * @protected\n\t\t */\n\t\tthis._now = Date.now;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @see module:watchdog/watchdog~WatchdogConfig\n\t\t */\n\t\tthis._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === 'number' ? config.minimumNonErrorTimePeriod : 5000;\n\n\t\t/**\n\t\t * Checks if the event error comes from the underlying item and restarts the item.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._boundErrorHandler = evt => {\n\t\t\t// `evt.error` is exposed by EventError while `evt.reason` is available in PromiseRejectionEvent.\n\t\t\tconst error = evt.error || evt.reason;\n\n\t\t\t// Note that `evt.reason` might be everything that is in the promise rejection.\n\t\t\t// Similarly everything that is thrown lands in `evt.error`.\n\t\t\tif ( error instanceof Error ) {\n\t\t\t\tthis._handleError( error, evt );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * The creation method.\n\t\t *\n\t\t * @protected\n\t\t * @member {Function} #_creator\n\t\t * @see #setCreator\n\t\t */\n\n\t\t/**\n\t\t * The destruction method.\n\t\t *\n\t\t * @protected\n\t\t * @member {Function} #_destructor\n\t\t * @see #setDestructor\n\t\t */\n\n\t\t/**\n\t\t * The watched item.\n\t\t *\n\t\t * @abstract\n\t\t * @protected\n\t\t * @member {Object|undefined} #_item\n\t\t */\n\n\t\t/**\n\t\t * The method responsible for restarting the watched item.\n\t\t *\n\t\t * @abstract\n\t\t * @protected\n\t\t * @method #_restart\n\t\t */\n\n\t\t/**\n\t\t * Traverses the error context and the watched item to find out whether the error should\n\t\t * be handled by the given item.\n\t\t *\n\t\t * @abstract\n\t\t * @protected\n\t\t * @method #_isErrorComingFromThisItem\n\t\t * @param {module:utils/ckeditorerror~CKEditorError} error\n\t\t */\n\n\t\t/**\n\t\t * A dictionary of event emitter listeners.\n\t\t *\n\t\t * @private\n\t\t * @type {Object.<String,Array.<Function>>}\n\t\t */\n\t\tthis._listeners = {};\n\n\t\tif ( !this._restart ) {\n\t\t\tthrow new Error(\n\t\t\t\t'The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' +\n\t\t\t\t'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.'\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the function that is responsible for creating watched items.\n\t *\n\t * @param {Function} creator A callback responsible for creating an item. Returns a promise\n\t * that is resolved when the item is created.\n\t */\n\tsetCreator( creator ) {\n\t\tthis._creator = creator;\n\t}\n\n\t/**\n\t * Sets the function that is responsible for destroying watched items.\n\t *\n\t * @param {Function} destructor A callback that takes the item and returns the promise\n\t * to the destroying process.\n\t */\n\tsetDestructor( destructor ) {\n\t\tthis._destructor = destructor;\n\t}\n\n\t/**\n\t * Destroys the watchdog and releases the resources.\n\t */\n\tdestroy() {\n\t\tthis._stopErrorHandling();\n\n\t\tthis._listeners = {};\n\t}\n\n\t/**\n\t * Starts listening to a specific event name by registering a callback that will be executed\n\t * whenever an event with a given name fires.\n\t *\n\t * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n\t *\n\t * @param {String} eventName The event name.\n\t * @param {Function} callback A callback which will be added to event listeners.\n\t */\n\ton( eventName, callback ) {\n\t\tif ( !this._listeners[ eventName ] ) {\n\t\t\tthis._listeners[ eventName ] = [];\n\t\t}\n\n\t\tthis._listeners[ eventName ].push( callback );\n\t}\n\n\t/**\n\t * Stops listening to the specified event name by removing the callback from event listeners.\n\t *\n\t * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n\t *\n\t * @param {String} eventName The event name.\n\t * @param {Function} callback A callback which will be removed from event listeners.\n\t */\n\toff( eventName, callback ) {\n\t\tthis._listeners[ eventName ] = this._listeners[ eventName ]\n\t\t\t.filter( cb => cb !== callback );\n\t}\n\n\t/**\n\t * Fires an event with a given event name and arguments.\n\t *\n\t * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n\t *\n\t * @protected\n\t * @param {String} eventName The event name.\n\t * @param  {...*} args Event arguments.\n\t */\n\t_fire( eventName, ...args ) {\n\t\tconst callbacks = this._listeners[ eventName ] || [];\n\n\t\tfor ( const callback of callbacks ) {\n\t\t\tcallback.apply( this, [ null, ...args ] );\n\t\t}\n\t}\n\n\t/**\n\t * Starts error handling by attaching global error handlers.\n\t *\n\t * @protected\n\t */\n\t_startErrorHandling() {\n\t\twindow.addEventListener( 'error', this._boundErrorHandler );\n\t\twindow.addEventListener( 'unhandledrejection', this._boundErrorHandler );\n\t}\n\n\t/**\n\t * Stops error handling by detaching global error handlers.\n\t *\n\t * @protected\n\t */\n\t_stopErrorHandling() {\n\t\twindow.removeEventListener( 'error', this._boundErrorHandler );\n\t\twindow.removeEventListener( 'unhandledrejection', this._boundErrorHandler );\n\t}\n\n\t/**\n\t * Checks if an error comes from the watched item and restarts it.\n\t * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.\n\t *\n\t * @private\n\t * @fires error\n\t * @param {Error} error Error.\n\t * @param {ErrorEvent|PromiseRejectionEvent} evt An error event.\n\t */\n\t_handleError( error, evt ) {\n\t\t// @if CK_DEBUG // if ( error.is && error.is( 'CKEditorError' ) && error.context === undefined ) {\n\t\t// @if CK_DEBUG // console.warn( 'The error is missing its context and Watchdog cannot restart the proper item.' );\n\t\t// @if CK_DEBUG // }\n\n\t\tif ( this._shouldReactToError( error ) ) {\n\t\t\tthis.crashes.push( {\n\t\t\t\tmessage: error.message,\n\t\t\t\tstack: error.stack,\n\n\t\t\t\t// `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events\n\t\t\t\tfilename: evt.filename,\n\t\t\t\tlineno: evt.lineno,\n\t\t\t\tcolno: evt.colno,\n\t\t\t\tdate: this._now()\n\t\t\t} );\n\n\t\t\tconst causesRestart = this._shouldRestart();\n\n\t\t\tthis.state = 'crashed';\n\t\t\tthis._fire( 'stateChange' );\n\t\t\tthis._fire( 'error', { error, causesRestart } );\n\n\t\t\tif ( causesRestart ) {\n\t\t\t\tthis._restart();\n\t\t\t} else {\n\t\t\t\tthis.state = 'crashedPermanently';\n\t\t\t\tthis._fire( 'stateChange' );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether an error should be handled by the watchdog.\n\t *\n\t * @private\n\t * @param {Error} error An error that was caught by the error handling process.\n\t */\n\t_shouldReactToError( error ) {\n\t\treturn (\n\t\t\terror.is &&\n\t\t\terror.is( 'CKEditorError' ) &&\n\t\t\terror.context !== undefined &&\n\n\t\t\t// In some cases the watched item should not be restarted - e.g. during the item initialization.\n\t\t\t// That's why the `null` was introduced as a correct error context which does cause restarting.\n\t\t\terror.context !== null &&\n\n\t\t\t// Do not react to errors if the watchdog is in states other than `ready`.\n\t\t\tthis.state === 'ready' &&\n\n\t\t\tthis._isErrorComingFromThisItem( error )\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the watchdog should restart the underlying item.\n\t *\n\t * @private\n\t */\n\t_shouldRestart() {\n\t\tif ( this.crashes.length <= this._crashNumberLimit ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst lastErrorTime = this.crashes[ this.crashes.length - 1 ].date;\n\t\tconst firstMeaningfulErrorTime = this.crashes[ this.crashes.length - 1 - this._crashNumberLimit ].date;\n\n\t\tconst averageNonErrorTimePeriod = ( lastErrorTime - firstMeaningfulErrorTime ) / this._crashNumberLimit;\n\n\t\treturn averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;\n\t}\n\n\t/**\n\t * Fired when a new {@link module:utils/ckeditorerror~CKEditorError `CKEditorError`} error connected to the watchdog instance occurs\n\t * and the watchdog will react to it.\n\t *\n\t * \twatchdog.on( 'error', ( evt, { error, causesRestart } ) => {\n\t * \t\tconsole.log( 'An error occurred.' );\n\t * \t} );\n\t *\n\t * @event error\n\t */\n}\n\n/**\n * The watchdog plugin configuration.\n *\n * @typedef {Object} WatchdogConfig\n *\n * @property {Number} [crashNumberLimit=3] A threshold specifying the number of watched item crashes\n * when the watchdog stops restarting the item in case of errors.\n * After this limit is reached and the time between the last errors is shorter than `minimumNonErrorTimePeriod`,\n * the watchdog changes its state to `crashedPermanently` and it stops restarting the item. This prevents an infinite restart loop.\n *\n * @property {Number} [minimumNonErrorTimePeriod=5000] An average number of milliseconds between the last watched item errors\n * (defaults to 5000). When the period of time between errors is lower than that and the `crashNumberLimit` is also reached,\n * the watchdog changes its state to `crashedPermanently` and it stops restarting the item. This prevents an infinite restart loop.\n *\n * @property {Number} [saveInterval=5000] A minimum number of milliseconds between saving the editor data internally (defaults to 5000).\n * Note that for large documents this might impact the editor performance.\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMA,QAAQ,CAAC;EAC7B;AACD;AACA;EACCC,WAAW,CAAEC,MAAM,EAAG;IACrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,OAAO,GAAG,EAAE;;IAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,KAAK,GAAG,cAAc;;IAE3B;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,iBAAiB,GAAG,OAAOH,MAAM,CAACI,gBAAgB,KAAK,QAAQ,GAAGJ,MAAM,CAACI,gBAAgB,GAAG,CAAC;;IAElG;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,IAAI,GAAGC,IAAI,CAACC,GAAG;;IAEpB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,0BAA0B,GAAG,OAAOR,MAAM,CAACS,yBAAyB,KAAK,QAAQ,GAAGT,MAAM,CAACS,yBAAyB,GAAG,IAAI;;IAEhI;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,kBAAkB,GAAGC,GAAG,IAAI;MAChC;MACA,MAAMC,KAAK,GAAGD,GAAG,CAACC,KAAK,IAAID,GAAG,CAACE,MAAM;;MAErC;MACA;MACA,IAAKD,KAAK,YAAYE,KAAK,EAAG;QAC7B,IAAI,CAACC,YAAY,CAAEH,KAAK,EAAED,GAAG,CAAE;MAChC;IACD,CAAC;;IAED;AACF;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACK,UAAU,GAAG,CAAC,CAAC;IAEpB,IAAK,CAAC,IAAI,CAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}