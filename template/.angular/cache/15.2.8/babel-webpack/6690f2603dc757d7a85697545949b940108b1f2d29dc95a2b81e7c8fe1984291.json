{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar AsyncSubject_1 = require('../AsyncSubject');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundCallbackObservable = function (_super) {\n  __extends(BoundCallbackObservable, _super);\n  function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n    _super.call(this);\n    this.callbackFunc = callbackFunc;\n    this.selector = selector;\n    this.args = args;\n    this.context = context;\n    this.scheduler = scheduler;\n  }\n  /* tslint:enable:max-line-length */\n  /**\n   * Converts a callback API to a function that returns an Observable.\n   *\n   * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n   * it will return a function `g` that when called as `g(x)` will output an\n   * Observable.</span>\n   *\n   * `bindCallback` is not an operator because its input and output are not\n   * Observables. The input is a function `func` with some parameters, the\n   * last parameter must be a callback function that `func` calls when it is\n   * done.\n   *\n   * The output of `bindCallback` is a function that takes the same parameters\n   * as `func`, except the last one (the callback). When the output function\n   * is called with arguments it will return an Observable. If function `func`\n   * calls its callback with one argument the Observable will emit that value.\n   * If on the other hand the callback is called with multiple values the resulting\n   * Observable will emit an array with said values as arguments.\n   *\n   * It is very important to remember that input function `func` is not called\n   * when the output function is, but rather when the Observable returned by the output\n   * function is subscribed. This means if `func` makes an AJAX request, that request\n   * will be made every time someone subscribes to the resulting Observable, but not before.\n   *\n   * Optionally, a selector function can be passed to `bindObservable`. The selector function\n   * takes the same arguments as the callback and returns the value that will be emitted by the Observable.\n   * Even though by default multiple arguments passed to callback appear in the stream as an array\n   * the selector function will be called with arguments directly, just as the callback would.\n   * This means you can imagine the default selector (when one is not provided explicitly)\n   * as a function that aggregates all its arguments into an array, or simply returns first argument\n   * if there is only one.\n   *\n   * The last optional parameter - {@link Scheduler} - can be used to control when the call\n   * to `func` happens after someone subscribes to Observable, as well as when results\n   * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`\n   * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,\n   * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler\n   * and call `subscribe` on the output Observable all function calls that are currently executing\n   * will end before `func` is invoked.\n   *\n   * By default results passed to the callback are emitted immediately after `func` invokes the callback.\n   * In particular, if the callback is called synchronously the subscription of the resulting Observable\n   * will call the `next` function synchronously as well.  If you want to defer that call,\n   * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can\n   * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n   *\n   * Note that the Observable created by the output function will always emit a single value\n   * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n   * calls will not appear in the stream. If you need to listen for multiple calls,\n   *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n   *\n   * If `func` depends on some context (`this` property) and is not already bound the context of `func`\n   * will be the context that the output function has at call time. In particular, if `func`\n   * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\n   * it is recommended that the context of the output function is set to that object as well.\n   *\n   * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n   * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n   * provides convenient error handling and probably is a better choice.\n   * `bindCallback` will treat such functions the same as any other and error parameters\n   * (whether passed or not) will always be interpreted as regular callback argument.\n   *\n   *\n   * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n   * // Suppose we have jQuery.getJSON('/my/url', callback)\n   * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n   * var result = getJSONAsObservable('/my/url');\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   *\n   * @example <caption>Receive an array of arguments passed to a callback</caption>\n   * someFunction((a, b, c) => {\n   *   console.log(a); // 5\n   *   console.log(b); // 'some string'\n   *   console.log(c); // {someProperty: 'someValue'}\n   * });\n   *\n   * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n   * boundSomeFunction().subscribe(values => {\n   *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n   * });\n   *\n   *\n   * @example <caption>Use bindCallback with a selector function</caption>\n   * someFunction((a, b, c) => {\n   *   console.log(a); // 'a'\n   *   console.log(b); // 'b'\n   *   console.log(c); // 'c'\n   * });\n   *\n   * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n   * boundSomeFunction().subscribe(value => {\n   *   console.log(value) // 'abc'\n   * });\n   *\n   *\n   * @example <caption>Compare behaviour with and without async Scheduler</caption>\n   * function iCallMyCallbackSynchronously(cb) {\n   *   cb();\n   * }\n   *\n   * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n   * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n   *\n   * boundSyncFn().subscribe(() => console.log('I was sync!'));\n   * boundAsyncFn().subscribe(() => console.log('I was async!'));\n   * console.log('This happened...');\n   *\n   * // Logs:\n   * // I was sync!\n   * // This happened...\n   * // I was async!\n   *\n   *\n   * @example <caption>Use bindCallback on an object method</caption>\n   * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n   * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n   * .subscribe(subscriber);\n   *\n   *\n   * @see {@link bindNodeCallback}\n   * @see {@link from}\n   * @see {@link fromPromise}\n   *\n   * @param {function} func A function with a callback as the last parameter.\n   * @param {function} [selector] A function which takes the arguments from the\n   * callback and maps them to a value that is emitted on the output Observable.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * callbacks.\n   * @return {function(...params: *): Observable} A function which returns the\n   * Observable that delivers the same values the callback would deliver.\n   * @static true\n   * @name bindCallback\n   * @owner Observable\n   */\n  BoundCallbackObservable.create = function (func, selector, scheduler) {\n    if (selector === void 0) {\n      selector = undefined;\n    }\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n      return new BoundCallbackObservable(func, selector, args, this, scheduler);\n    };\n  };\n  /** @deprecated internal use only */\n  BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n    var callbackFunc = this.callbackFunc;\n    var args = this.args;\n    var scheduler = this.scheduler;\n    var subject = this.subject;\n    if (!scheduler) {\n      if (!subject) {\n        subject = this.subject = new AsyncSubject_1.AsyncSubject();\n        var handler = function handlerFn() {\n          var innerArgs = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            innerArgs[_i - 0] = arguments[_i];\n          }\n          var source = handlerFn.source;\n          var selector = source.selector,\n            subject = source.subject;\n          if (selector) {\n            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n            if (result_1 === errorObject_1.errorObject) {\n              subject.error(errorObject_1.errorObject.e);\n            } else {\n              subject.next(result_1);\n              subject.complete();\n            }\n          } else {\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          }\n        };\n        // use named function instance to avoid closure.\n        handler.source = this;\n        var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n        if (result === errorObject_1.errorObject) {\n          subject.error(errorObject_1.errorObject.e);\n        }\n      }\n      return subject.subscribe(subscriber);\n    } else {\n      return scheduler.schedule(BoundCallbackObservable.dispatch, 0, {\n        source: this,\n        subscriber: subscriber,\n        context: this.context\n      });\n    }\n  };\n  BoundCallbackObservable.dispatch = function (state) {\n    var self = this;\n    var source = state.source,\n      subscriber = state.subscriber,\n      context = state.context;\n    var callbackFunc = source.callbackFunc,\n      args = source.args,\n      scheduler = source.scheduler;\n    var subject = source.subject;\n    if (!subject) {\n      subject = source.subject = new AsyncSubject_1.AsyncSubject();\n      var handler = function handlerFn() {\n        var innerArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          innerArgs[_i - 0] = arguments[_i];\n        }\n        var source = handlerFn.source;\n        var selector = source.selector,\n          subject = source.subject;\n        if (selector) {\n          var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n          if (result_2 === errorObject_1.errorObject) {\n            self.add(scheduler.schedule(dispatchError, 0, {\n              err: errorObject_1.errorObject.e,\n              subject: subject\n            }));\n          } else {\n            self.add(scheduler.schedule(dispatchNext, 0, {\n              value: result_2,\n              subject: subject\n            }));\n          }\n        } else {\n          var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n          self.add(scheduler.schedule(dispatchNext, 0, {\n            value: value,\n            subject: subject\n          }));\n        }\n      };\n      // use named function to pass values in without closure\n      handler.source = source;\n      var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n      if (result === errorObject_1.errorObject) {\n        subject.error(errorObject_1.errorObject.e);\n      }\n    }\n    self.add(subject.subscribe(subscriber));\n  };\n  return BoundCallbackObservable;\n}(Observable_1.Observable);\nexports.BoundCallbackObservable = BoundCallbackObservable;\nfunction dispatchNext(arg) {\n  var value = arg.value,\n    subject = arg.subject;\n  subject.next(value);\n  subject.complete();\n}\nfunction dispatchError(arg) {\n  var err = arg.err,\n    subject = arg.subject;\n  subject.error(err);\n}","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Observable_1","require","tryCatch_1","errorObject_1","AsyncSubject_1","BoundCallbackObservable","_super","callbackFunc","selector","args","context","scheduler","call","func","undefined","_i","arguments","length","_subscribe","subscriber","subject","AsyncSubject","handler","handlerFn","innerArgs","source","result_1","tryCatch","apply","errorObject","error","e","next","complete","result","concat","subscribe","schedule","dispatch","state","self","result_2","add","dispatchError","err","dispatchNext","value","Observable","exports","arg"],"sources":["F:/Plantillas/template/node_modules/ng5-slider/node_modules/rxjs/observable/BoundCallbackObservable.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar AsyncSubject_1 = require('../AsyncSubject');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundCallbackObservable = (function (_super) {\n    __extends(BoundCallbackObservable, _super);\n    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n        _super.call(this);\n        this.callbackFunc = callbackFunc;\n        this.selector = selector;\n        this.args = args;\n        this.context = context;\n        this.scheduler = scheduler;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a callback API to a function that returns an Observable.\n     *\n     * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n     * it will return a function `g` that when called as `g(x)` will output an\n     * Observable.</span>\n     *\n     * `bindCallback` is not an operator because its input and output are not\n     * Observables. The input is a function `func` with some parameters, the\n     * last parameter must be a callback function that `func` calls when it is\n     * done.\n     *\n     * The output of `bindCallback` is a function that takes the same parameters\n     * as `func`, except the last one (the callback). When the output function\n     * is called with arguments it will return an Observable. If function `func`\n     * calls its callback with one argument the Observable will emit that value.\n     * If on the other hand the callback is called with multiple values the resulting\n     * Observable will emit an array with said values as arguments.\n     *\n     * It is very important to remember that input function `func` is not called\n     * when the output function is, but rather when the Observable returned by the output\n     * function is subscribed. This means if `func` makes an AJAX request, that request\n     * will be made every time someone subscribes to the resulting Observable, but not before.\n     *\n     * Optionally, a selector function can be passed to `bindObservable`. The selector function\n     * takes the same arguments as the callback and returns the value that will be emitted by the Observable.\n     * Even though by default multiple arguments passed to callback appear in the stream as an array\n     * the selector function will be called with arguments directly, just as the callback would.\n     * This means you can imagine the default selector (when one is not provided explicitly)\n     * as a function that aggregates all its arguments into an array, or simply returns first argument\n     * if there is only one.\n     *\n     * The last optional parameter - {@link Scheduler} - can be used to control when the call\n     * to `func` happens after someone subscribes to Observable, as well as when results\n     * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`\n     * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,\n     * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler\n     * and call `subscribe` on the output Observable all function calls that are currently executing\n     * will end before `func` is invoked.\n     *\n     * By default results passed to the callback are emitted immediately after `func` invokes the callback.\n     * In particular, if the callback is called synchronously the subscription of the resulting Observable\n     * will call the `next` function synchronously as well.  If you want to defer that call,\n     * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can\n     * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n     *\n     * Note that the Observable created by the output function will always emit a single value\n     * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n     * calls will not appear in the stream. If you need to listen for multiple calls,\n     *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n     *\n     * If `func` depends on some context (`this` property) and is not already bound the context of `func`\n     * will be the context that the output function has at call time. In particular, if `func`\n     * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\n     * it is recommended that the context of the output function is set to that object as well.\n     *\n     * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n     * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n     * provides convenient error handling and probably is a better choice.\n     * `bindCallback` will treat such functions the same as any other and error parameters\n     * (whether passed or not) will always be interpreted as regular callback argument.\n     *\n     *\n     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n     * // Suppose we have jQuery.getJSON('/my/url', callback)\n     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n     * var result = getJSONAsObservable('/my/url');\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     *\n     * @example <caption>Receive an array of arguments passed to a callback</caption>\n     * someFunction((a, b, c) => {\n     *   console.log(a); // 5\n     *   console.log(b); // 'some string'\n     *   console.log(c); // {someProperty: 'someValue'}\n     * });\n     *\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n     * boundSomeFunction().subscribe(values => {\n     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n     * });\n     *\n     *\n     * @example <caption>Use bindCallback with a selector function</caption>\n     * someFunction((a, b, c) => {\n     *   console.log(a); // 'a'\n     *   console.log(b); // 'b'\n     *   console.log(c); // 'c'\n     * });\n     *\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n     * boundSomeFunction().subscribe(value => {\n     *   console.log(value) // 'abc'\n     * });\n     *\n     *\n     * @example <caption>Compare behaviour with and without async Scheduler</caption>\n     * function iCallMyCallbackSynchronously(cb) {\n     *   cb();\n     * }\n     *\n     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n     *\n     * boundSyncFn().subscribe(() => console.log('I was sync!'));\n     * boundAsyncFn().subscribe(() => console.log('I was async!'));\n     * console.log('This happened...');\n     *\n     * // Logs:\n     * // I was sync!\n     * // This happened...\n     * // I was async!\n     *\n     *\n     * @example <caption>Use bindCallback on an object method</caption>\n     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n     * .subscribe(subscriber);\n     *\n     *\n     * @see {@link bindNodeCallback}\n     * @see {@link from}\n     * @see {@link fromPromise}\n     *\n     * @param {function} func A function with a callback as the last parameter.\n     * @param {function} [selector] A function which takes the arguments from the\n     * callback and maps them to a value that is emitted on the output Observable.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * callbacks.\n     * @return {function(...params: *): Observable} A function which returns the\n     * Observable that delivers the same values the callback would deliver.\n     * @static true\n     * @name bindCallback\n     * @owner Observable\n     */\n    BoundCallbackObservable.create = function (func, selector, scheduler) {\n        if (selector === void 0) { selector = undefined; }\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new BoundCallbackObservable(func, selector, args, this, scheduler);\n        };\n    };\n    /** @deprecated internal use only */ BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n        var callbackFunc = this.callbackFunc;\n        var args = this.args;\n        var scheduler = this.scheduler;\n        var subject = this.subject;\n        if (!scheduler) {\n            if (!subject) {\n                subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i - 0] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    if (selector) {\n                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_1 === errorObject_1.errorObject) {\n                            subject.error(errorObject_1.errorObject.e);\n                        }\n                        else {\n                            subject.next(result_1);\n                            subject.complete();\n                        }\n                    }\n                    else {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    }\n                };\n                // use named function instance to avoid closure.\n                handler.source = this;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            return subject.subscribe(subscriber);\n        }\n        else {\n            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n        }\n    };\n    BoundCallbackObservable.dispatch = function (state) {\n        var self = this;\n        var source = state.source, subscriber = state.subscriber, context = state.context;\n        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\n        var subject = source.subject;\n        if (!subject) {\n            subject = source.subject = new AsyncSubject_1.AsyncSubject();\n            var handler = function handlerFn() {\n                var innerArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    innerArgs[_i - 0] = arguments[_i];\n                }\n                var source = handlerFn.source;\n                var selector = source.selector, subject = source.subject;\n                if (selector) {\n                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                    if (result_2 === errorObject_1.errorObject) {\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                    }\n                    else {\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                    }\n                }\n                else {\n                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                }\n            };\n            // use named function to pass values in without closure\n            handler.source = source;\n            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n            if (result === errorObject_1.errorObject) {\n                subject.error(errorObject_1.errorObject.e);\n            }\n        }\n        self.add(subject.subscribe(subscriber));\n    };\n    return BoundCallbackObservable;\n}(Observable_1.Observable));\nexports.BoundCallbackObservable = BoundCallbackObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAK,UAAUC,CAAC,EAAEC,CAAC,EAAE;EACxD,KAAK,IAAIC,CAAC,IAAID,CAAC,EAAE,IAAIA,CAAC,CAACE,cAAc,CAACD,CAAC,CAAC,EAAEF,CAAC,CAACE,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,CAAC;EACrD,SAASE,EAAE,GAAG;IAAE,IAAI,CAACC,WAAW,GAAGL,CAAC;EAAE;EACtCA,CAAC,CAACM,SAAS,GAAGL,CAAC,KAAK,IAAI,GAAGM,MAAM,CAACC,MAAM,CAACP,CAAC,CAAC,IAAIG,EAAE,CAACE,SAAS,GAAGL,CAAC,CAACK,SAAS,EAAE,IAAIF,EAAE,EAAE,CAAC;AACxF,CAAC;AACD,IAAIK,YAAY,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC3C,IAAIC,UAAU,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAC5C,IAAIE,aAAa,GAAGF,OAAO,CAAC,qBAAqB,CAAC;AAClD,IAAIG,cAAc,GAAGH,OAAO,CAAC,iBAAiB,CAAC;AAC/C;AACA;AACA;AACA;AACA;AACA,IAAII,uBAAuB,GAAI,UAAUC,MAAM,EAAE;EAC7ChB,SAAS,CAACe,uBAAuB,EAAEC,MAAM,CAAC;EAC1C,SAASD,uBAAuB,CAACE,YAAY,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,OAAO,EAAEC,SAAS,EAAE;IAC/EL,MAAM,CAACM,IAAI,CAAC,IAAI,CAAC;IACjB,IAAI,CAACL,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;EAC9B;EACA;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIN,uBAAuB,CAACN,MAAM,GAAG,UAAUc,IAAI,EAAEL,QAAQ,EAAEG,SAAS,EAAE;IAClE,IAAIH,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAGM,SAAS;IAAE;IACjD,OAAO,YAAY;MACf,IAAIL,IAAI,GAAG,EAAE;MACb,KAAK,IAAIM,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;QAC1CN,IAAI,CAACM,EAAE,GAAG,CAAC,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;MAChC;MACA,OAAO,IAAIV,uBAAuB,CAACQ,IAAI,EAAEL,QAAQ,EAAEC,IAAI,EAAE,IAAI,EAAEE,SAAS,CAAC;IAC7E,CAAC;EACL,CAAC;EACD;EAAqCN,uBAAuB,CAACR,SAAS,CAACqB,UAAU,GAAG,UAAUC,UAAU,EAAE;IACtG,IAAIZ,YAAY,GAAG,IAAI,CAACA,YAAY;IACpC,IAAIE,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIE,SAAS,GAAG,IAAI,CAACA,SAAS;IAC9B,IAAIS,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAI,CAACT,SAAS,EAAE;MACZ,IAAI,CAACS,OAAO,EAAE;QACVA,OAAO,GAAG,IAAI,CAACA,OAAO,GAAG,IAAIhB,cAAc,CAACiB,YAAY,EAAE;QAC1D,IAAIC,OAAO,GAAG,SAASC,SAAS,GAAG;UAC/B,IAAIC,SAAS,GAAG,EAAE;UAClB,KAAK,IAAIT,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;YAC1CS,SAAS,CAACT,EAAE,GAAG,CAAC,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;UACrC;UACA,IAAIU,MAAM,GAAGF,SAAS,CAACE,MAAM;UAC7B,IAAIjB,QAAQ,GAAGiB,MAAM,CAACjB,QAAQ;YAAEY,OAAO,GAAGK,MAAM,CAACL,OAAO;UACxD,IAAIZ,QAAQ,EAAE;YACV,IAAIkB,QAAQ,GAAGxB,UAAU,CAACyB,QAAQ,CAACnB,QAAQ,CAAC,CAACoB,KAAK,CAAC,IAAI,EAAEJ,SAAS,CAAC;YACnE,IAAIE,QAAQ,KAAKvB,aAAa,CAAC0B,WAAW,EAAE;cACxCT,OAAO,CAACU,KAAK,CAAC3B,aAAa,CAAC0B,WAAW,CAACE,CAAC,CAAC;YAC9C,CAAC,MACI;cACDX,OAAO,CAACY,IAAI,CAACN,QAAQ,CAAC;cACtBN,OAAO,CAACa,QAAQ,EAAE;YACtB;UACJ,CAAC,MACI;YACDb,OAAO,CAACY,IAAI,CAACR,SAAS,CAACP,MAAM,IAAI,CAAC,GAAGO,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC;YAC9DJ,OAAO,CAACa,QAAQ,EAAE;UACtB;QACJ,CAAC;QACD;QACAX,OAAO,CAACG,MAAM,GAAG,IAAI;QACrB,IAAIS,MAAM,GAAGhC,UAAU,CAACyB,QAAQ,CAACpB,YAAY,CAAC,CAACqB,KAAK,CAAC,IAAI,CAAClB,OAAO,EAAED,IAAI,CAAC0B,MAAM,CAACb,OAAO,CAAC,CAAC;QACxF,IAAIY,MAAM,KAAK/B,aAAa,CAAC0B,WAAW,EAAE;UACtCT,OAAO,CAACU,KAAK,CAAC3B,aAAa,CAAC0B,WAAW,CAACE,CAAC,CAAC;QAC9C;MACJ;MACA,OAAOX,OAAO,CAACgB,SAAS,CAACjB,UAAU,CAAC;IACxC,CAAC,MACI;MACD,OAAOR,SAAS,CAAC0B,QAAQ,CAAChC,uBAAuB,CAACiC,QAAQ,EAAE,CAAC,EAAE;QAAEb,MAAM,EAAE,IAAI;QAAEN,UAAU,EAAEA,UAAU;QAAET,OAAO,EAAE,IAAI,CAACA;MAAQ,CAAC,CAAC;IACnI;EACJ,CAAC;EACDL,uBAAuB,CAACiC,QAAQ,GAAG,UAAUC,KAAK,EAAE;IAChD,IAAIC,IAAI,GAAG,IAAI;IACf,IAAIf,MAAM,GAAGc,KAAK,CAACd,MAAM;MAAEN,UAAU,GAAGoB,KAAK,CAACpB,UAAU;MAAET,OAAO,GAAG6B,KAAK,CAAC7B,OAAO;IACjF,IAAIH,YAAY,GAAGkB,MAAM,CAAClB,YAAY;MAAEE,IAAI,GAAGgB,MAAM,CAAChB,IAAI;MAAEE,SAAS,GAAGc,MAAM,CAACd,SAAS;IACxF,IAAIS,OAAO,GAAGK,MAAM,CAACL,OAAO;IAC5B,IAAI,CAACA,OAAO,EAAE;MACVA,OAAO,GAAGK,MAAM,CAACL,OAAO,GAAG,IAAIhB,cAAc,CAACiB,YAAY,EAAE;MAC5D,IAAIC,OAAO,GAAG,SAASC,SAAS,GAAG;QAC/B,IAAIC,SAAS,GAAG,EAAE;QAClB,KAAK,IAAIT,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;UAC1CS,SAAS,CAACT,EAAE,GAAG,CAAC,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;QACrC;QACA,IAAIU,MAAM,GAAGF,SAAS,CAACE,MAAM;QAC7B,IAAIjB,QAAQ,GAAGiB,MAAM,CAACjB,QAAQ;UAAEY,OAAO,GAAGK,MAAM,CAACL,OAAO;QACxD,IAAIZ,QAAQ,EAAE;UACV,IAAIiC,QAAQ,GAAGvC,UAAU,CAACyB,QAAQ,CAACnB,QAAQ,CAAC,CAACoB,KAAK,CAAC,IAAI,EAAEJ,SAAS,CAAC;UACnE,IAAIiB,QAAQ,KAAKtC,aAAa,CAAC0B,WAAW,EAAE;YACxCW,IAAI,CAACE,GAAG,CAAC/B,SAAS,CAAC0B,QAAQ,CAACM,aAAa,EAAE,CAAC,EAAE;cAAEC,GAAG,EAAEzC,aAAa,CAAC0B,WAAW,CAACE,CAAC;cAAEX,OAAO,EAAEA;YAAQ,CAAC,CAAC,CAAC;UAC1G,CAAC,MACI;YACDoB,IAAI,CAACE,GAAG,CAAC/B,SAAS,CAAC0B,QAAQ,CAACQ,YAAY,EAAE,CAAC,EAAE;cAAEC,KAAK,EAAEL,QAAQ;cAAErB,OAAO,EAAEA;YAAQ,CAAC,CAAC,CAAC;UACxF;QACJ,CAAC,MACI;UACD,IAAI0B,KAAK,GAAGtB,SAAS,CAACP,MAAM,IAAI,CAAC,GAAGO,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS;UAC5DgB,IAAI,CAACE,GAAG,CAAC/B,SAAS,CAAC0B,QAAQ,CAACQ,YAAY,EAAE,CAAC,EAAE;YAAEC,KAAK,EAAEA,KAAK;YAAE1B,OAAO,EAAEA;UAAQ,CAAC,CAAC,CAAC;QACrF;MACJ,CAAC;MACD;MACAE,OAAO,CAACG,MAAM,GAAGA,MAAM;MACvB,IAAIS,MAAM,GAAGhC,UAAU,CAACyB,QAAQ,CAACpB,YAAY,CAAC,CAACqB,KAAK,CAAClB,OAAO,EAAED,IAAI,CAAC0B,MAAM,CAACb,OAAO,CAAC,CAAC;MACnF,IAAIY,MAAM,KAAK/B,aAAa,CAAC0B,WAAW,EAAE;QACtCT,OAAO,CAACU,KAAK,CAAC3B,aAAa,CAAC0B,WAAW,CAACE,CAAC,CAAC;MAC9C;IACJ;IACAS,IAAI,CAACE,GAAG,CAACtB,OAAO,CAACgB,SAAS,CAACjB,UAAU,CAAC,CAAC;EAC3C,CAAC;EACD,OAAOd,uBAAuB;AAClC,CAAC,CAACL,YAAY,CAAC+C,UAAU,CAAE;AAC3BC,OAAO,CAAC3C,uBAAuB,GAAGA,uBAAuB;AACzD,SAASwC,YAAY,CAACI,GAAG,EAAE;EACvB,IAAIH,KAAK,GAAGG,GAAG,CAACH,KAAK;IAAE1B,OAAO,GAAG6B,GAAG,CAAC7B,OAAO;EAC5CA,OAAO,CAACY,IAAI,CAACc,KAAK,CAAC;EACnB1B,OAAO,CAACa,QAAQ,EAAE;AACtB;AACA,SAASU,aAAa,CAACM,GAAG,EAAE;EACxB,IAAIL,GAAG,GAAGK,GAAG,CAACL,GAAG;IAAExB,OAAO,GAAG6B,GAAG,CAAC7B,OAAO;EACxCA,OAAO,CAACU,KAAK,CAACc,GAAG,CAAC;AACtB"},"metadata":{},"sourceType":"script","externalDependencies":[]}