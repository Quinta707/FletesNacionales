{"ast":null,"code":"'use strict';\n\nvar emitter = require('contra/emitter');\nvar crossvent = require('crossvent');\nvar classes = require('./classes');\nvar doc = document;\nvar documentElement = doc.documentElement;\nfunction dragula(initialContainers, options) {\n  var len = arguments.length;\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n  var _mirror; // mirror image\n  var _source; // source container\n  var _item; // item being dragged\n  var _offsetX; // reference x\n  var _offsetY; // reference y\n  var _moveX; // reference move x\n  var _moveY; // reference move y\n  var _initialSibling; // reference sibling when grabbed\n  var _currentSibling; // reference sibling now\n  var _copy; // item used for copying\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n  var _lastDropTarget = null; // last container item was over\n  var _grabbed; // holds mousedown context until first mousemove\n\n  var o = options || {};\n  if (o.moves === void 0) {\n    o.moves = always;\n  }\n  if (o.accepts === void 0) {\n    o.accepts = always;\n  }\n  if (o.invalid === void 0) {\n    o.invalid = invalidTarget;\n  }\n  if (o.containers === void 0) {\n    o.containers = initialContainers || [];\n  }\n  if (o.isContainer === void 0) {\n    o.isContainer = never;\n  }\n  if (o.copy === void 0) {\n    o.copy = false;\n  }\n  if (o.copySortSource === void 0) {\n    o.copySortSource = false;\n  }\n  if (o.revertOnSpill === void 0) {\n    o.revertOnSpill = false;\n  }\n  if (o.removeOnSpill === void 0) {\n    o.removeOnSpill = false;\n  }\n  if (o.direction === void 0) {\n    o.direction = 'vertical';\n  }\n  if (o.ignoreInputTextSelection === void 0) {\n    o.ignoreInputTextSelection = true;\n  }\n  if (o.mirrorContainer === void 0) {\n    o.mirrorContainer = doc.body;\n  }\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n  events();\n  return drake;\n  function isContainer(el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n  function events(remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n  function eventualMovements(remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n  function movements(remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n  function destroy() {\n    events(true);\n    release({});\n  }\n  function preventGrabbed(e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n  function grab(e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n\n    var item = e.target;\n    var context = canStart(item);\n    if (!context) {\n      return;\n    }\n    _grabbed = context;\n    eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) {\n        // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved(e) {\n    if (!_grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n\n    // truthy check fixes #239, equality fixes #207, fixes #501\n    if (e.clientX !== void 0 && Math.abs(e.clientX - _moveX) <= (o.slideFactorX || 0) && e.clientY !== void 0 && Math.abs(e.clientY - _moveY) <= (o.slideFactorY || 0)) {\n      return;\n    }\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e) || 0;\n      var clientY = getCoord('clientY', e) || 0;\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n  function canStart(item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n\n    var handle = item;\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    var source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (o.invalid(item, handle)) {\n      return;\n    }\n    var movable = o.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n    return {\n      item: item,\n      source: source\n    };\n  }\n  function canMove(item) {\n    return !!canStart(item);\n  }\n  function manualStart(item) {\n    var context = canStart(item);\n    if (context) {\n      start(context);\n    }\n  }\n  function start(context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n  function invalidTarget() {\n    return false;\n  }\n  function end() {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n  function ungrab() {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n  function release(e) {\n    ungrab();\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e) || 0;\n    var clientY = getCoord('clientY', e) || 0;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    if (dropTarget && (_copy && o.copySortSource || !_copy || dropTarget !== _source)) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n  function drop(item, target) {\n    var parent = getParent(item);\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n    cleanup();\n  }\n  function remove() {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n  function cancel(revert) {\n    if (!drake.dragging) {\n      return;\n    }\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n    cleanup();\n  }\n  function cleanup() {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n    drake.dragging = false;\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n  function isInitialPlacement(target, s) {\n    var sibling;\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n    return target === _source && sibling === _initialSibling;\n  }\n  function findDropTarget(elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n    return target;\n    function accepted() {\n      var droppable = isContainer(target);\n      if (droppable === false) {\n        return false;\n      }\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n  function drag(e) {\n    if (!_mirror) {\n      return;\n    }\n    e.preventDefault();\n    var clientX = getCoord('clientX', e) || 0;\n    var clientY = getCoord('clientY', e) || 0;\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n    var parent = getParent(item);\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (reference === null && changed || reference !== item && reference !== nextEl(item)) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n    function moved(type) {\n      drake.emit(type, item, _lastDropTarget, _source);\n    }\n    function over() {\n      if (changed) {\n        moved('over');\n      }\n    }\n    function out() {\n      if (_lastDropTarget) {\n        moved('out');\n      }\n    }\n  }\n  function spillOver(el) {\n    classes.rm(el, 'gu-hide');\n  }\n  function spillOut(el) {\n    if (drake.dragging) {\n      classes.add(el, 'gu-hide');\n    }\n  }\n  function renderMirrorImage() {\n    if (_mirror) {\n      return;\n    }\n    var rect = _item.getBoundingClientRect();\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n  function removeMirrorImage() {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n  function getImmediateChild(dropTarget, target) {\n    var immediate = target;\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n    if (immediate === documentElement) {\n      return null;\n    }\n    return immediate;\n  }\n  function getReference(dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n    function outside() {\n      // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && rect.left + rect.width / 2 > x) {\n          return el;\n        }\n        if (!horizontal && rect.top + rect.height / 2 > y) {\n          return el;\n        }\n      }\n      return null;\n    }\n    function inside() {\n      // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n    function resolve(after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n  function isCopy(item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\nfunction touchy(el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\nfunction whichMouseButton(e) {\n  if (e.touches !== void 0) {\n    return e.touches.length;\n  }\n  if (e.which !== void 0 && e.which !== 0) {\n    return e.which;\n  } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== void 0) {\n    return e.buttons;\n  }\n  var button = e.button;\n  if (button !== void 0) {\n    // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n}\nfunction getOffset(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\nfunction getScroll(scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\nfunction getElementBehindPoint(point, x, y) {\n  point = point || {};\n  var state = point.className || '';\n  var el;\n  point.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  point.className = state;\n  return el;\n}\nfunction never() {\n  return false;\n}\nfunction always() {\n  return true;\n}\nfunction getRectWidth(rect) {\n  return rect.width || rect.right - rect.left;\n}\nfunction getRectHeight(rect) {\n  return rect.height || rect.bottom - rect.top;\n}\nfunction getParent(el) {\n  return el.parentNode === doc ? null : el.parentNode;\n}\nfunction isInput(el) {\n  return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n}\nfunction isEditable(el) {\n  if (!el) {\n    return false;\n  } // no parents were editable\n  if (el.contentEditable === 'false') {\n    return false;\n  } // stop the lookup\n  if (el.contentEditable === 'true') {\n    return true;\n  } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl(el) {\n  return el.nextElementSibling || manually();\n  function manually() {\n    var sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n}\nfunction getEventHost(e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\nfunction getCoord(coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX',\n    // IE8\n    pageY: 'clientY' // IE8\n  };\n\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n  return host[coord];\n}\nmodule.exports = dragula;","map":{"version":3,"names":["emitter","require","crossvent","classes","doc","document","documentElement","dragula","initialContainers","options","len","arguments","length","Array","isArray","_mirror","_source","_item","_offsetX","_offsetY","_moveX","_moveY","_initialSibling","_currentSibling","_copy","_renderTimer","_lastDropTarget","_grabbed","o","moves","always","accepts","invalid","invalidTarget","containers","isContainer","never","copy","copySortSource","revertOnSpill","removeOnSpill","direction","ignoreInputTextSelection","mirrorContainer","body","drake","start","manualStart","end","cancel","remove","destroy","canMove","dragging","on","spillOver","spillOut","events","el","indexOf","op","touchy","grab","release","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","e","preventDefault","clientX","clientY","ignore","whichMouseButton","metaKey","ctrlKey","item","target","context","canStart","type","isInput","focus","Math","abs","slideFactorX","slideFactorY","getCoord","elementBehindCursor","elementFromPoint","grabbed","offset","getOffset","left","top","add","renderMirrorImage","drag","handle","getParent","source","movable","nextEl","isCopy","cloneNode","emit","drop","ungrab","getElementBehindPoint","dropTarget","findDropTarget","parent","removeChild","isInitialPlacement","cleanup","revert","reverts","initial","insertBefore","removeMirrorImage","rm","clearTimeout","s","sibling","accepted","droppable","immediate","getImmediateChild","reference","getReference","x","y","style","changed","out","over","moved","rect","getBoundingClientRect","width","getRectWidth","height","getRectHeight","appendChild","horizontal","inside","outside","children","i","resolve","after","container","fn","touch","mouseup","mousedown","mousemove","pointers","microsoft","global","navigator","pointerEnabled","msPointerEnabled","touches","which","buttons","button","getScroll","scrollProp","offsetProp","clientHeight","point","state","className","right","bottom","parentNode","tagName","isEditable","contentEditable","nextElementSibling","manually","nextSibling","nodeType","getEventHost","targetTouches","changedTouches","coord","host","missMap","pageX","pageY","module","exports"],"sources":["C:/Users/Sarai Quintanilla/Documents/GitHub/FletesNacionales/template/node_modules/dragula/dragula.js"],"sourcesContent":["'use strict';\n\nvar emitter = require('contra/emitter');\nvar crossvent = require('crossvent');\nvar classes = require('./classes');\nvar doc = document;\nvar documentElement = doc.documentElement;\n\nfunction dragula (initialContainers, options) {\n  var len = arguments.length;\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n  var _mirror; // mirror image\n  var _source; // source container\n  var _item; // item being dragged\n  var _offsetX; // reference x\n  var _offsetY; // reference y\n  var _moveX; // reference move x\n  var _moveY; // reference move y\n  var _initialSibling; // reference sibling when grabbed\n  var _currentSibling; // reference sibling now\n  var _copy; // item used for copying\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n  var _lastDropTarget = null; // last container item was over\n  var _grabbed; // holds mousedown context until first mousemove\n\n  var o = options || {};\n  if (o.moves === void 0) { o.moves = always; }\n  if (o.accepts === void 0) { o.accepts = always; }\n  if (o.invalid === void 0) { o.invalid = invalidTarget; }\n  if (o.containers === void 0) { o.containers = initialContainers || []; }\n  if (o.isContainer === void 0) { o.isContainer = never; }\n  if (o.copy === void 0) { o.copy = false; }\n  if (o.copySortSource === void 0) { o.copySortSource = false; }\n  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\n  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\n  if (o.direction === void 0) { o.direction = 'vertical'; }\n  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }\n  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }\n\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n\n  events();\n\n  return drake;\n\n  function isContainer (el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n\n  function events (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n\n  function eventualMovements (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n\n  function movements (remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n\n  function destroy () {\n    events(true);\n    release({});\n  }\n\n  function preventGrabbed (e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function grab (e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n    var item = e.target;\n    var context = canStart(item);\n    if (!context) {\n      return;\n    }\n    _grabbed = context;\n    eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved (e) {\n    if (!_grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n\n    // truthy check fixes #239, equality fixes #207, fixes #501\n    if ((e.clientX !== void 0 && Math.abs(e.clientX - _moveX) <= (o.slideFactorX || 0)) &&\n      (e.clientY !== void 0 && Math.abs(e.clientY - _moveY) <= (o.slideFactorY || 0))) {\n      return;\n    }\n\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e) || 0;\n      var clientY = getCoord('clientY', e) || 0;\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n\n  function canStart (item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n    var handle = item;\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    var source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (o.invalid(item, handle)) {\n      return;\n    }\n\n    var movable = o.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n\n    return {\n      item: item,\n      source: source\n    };\n  }\n\n  function canMove (item) {\n    return !!canStart(item);\n  }\n\n  function manualStart (item) {\n    var context = canStart(item);\n    if (context) {\n      start(context);\n    }\n  }\n\n  function start (context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n\n  function invalidTarget () {\n    return false;\n  }\n\n  function end () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n\n  function ungrab () {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n\n  function release (e) {\n    ungrab();\n\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e) || 0;\n    var clientY = getCoord('clientY', e) || 0;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n\n  function drop (item, target) {\n    var parent = getParent(item);\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function remove () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n\n  function cancel (revert) {\n    if (!drake.dragging) {\n      return;\n    }\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function cleanup () {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n    drake.dragging = false;\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n\n  function isInitialPlacement (target, s) {\n    var sibling;\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n    return target === _source && sibling === _initialSibling;\n  }\n\n  function findDropTarget (elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n    return target;\n\n    function accepted () {\n      var droppable = isContainer(target);\n      if (droppable === false) {\n        return false;\n      }\n\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n\n  function drag (e) {\n    if (!_mirror) {\n      return;\n    }\n    e.preventDefault();\n\n    var clientX = getCoord('clientX', e) || 0;\n    var clientY = getCoord('clientY', e) || 0;\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n    var parent = getParent(item);\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (\n      (reference === null && changed) ||\n      reference !== item &&\n      reference !== nextEl(item)\n    ) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }\n    function over () { if (changed) { moved('over'); } }\n    function out () { if (_lastDropTarget) { moved('out'); } }\n  }\n\n  function spillOver (el) {\n    classes.rm(el, 'gu-hide');\n  }\n\n  function spillOut (el) {\n    if (drake.dragging) { classes.add(el, 'gu-hide'); }\n  }\n\n  function renderMirrorImage () {\n    if (_mirror) {\n      return;\n    }\n    var rect = _item.getBoundingClientRect();\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n\n  function removeMirrorImage () {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n\n  function getImmediateChild (dropTarget, target) {\n    var immediate = target;\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n    if (immediate === documentElement) {\n      return null;\n    }\n    return immediate;\n  }\n\n  function getReference (dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n\n    function outside () { // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\n        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\n      }\n      return null;\n    }\n\n    function inside () { // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    function resolve (after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n\n  function isCopy (item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\n\nfunction touchy (el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\n\nfunction whichMouseButton (e) {\n  if (e.touches !== void 0) { return e.touches.length; }\n  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== void 0) { return e.buttons; }\n  var button = e.button;\n  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n  }\n}\n\nfunction getOffset (el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\n\nfunction getScroll (scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\n\nfunction getElementBehindPoint (point, x, y) {\n  point = point || {};\n  var state = point.className || '';\n  var el;\n  point.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  point.className = state;\n  return el;\n}\n\nfunction never () { return false; }\nfunction always () { return true; }\nfunction getRectWidth (rect) { return rect.width || (rect.right - rect.left); }\nfunction getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }\nfunction getParent (el) { return el.parentNode === doc ? null : el.parentNode; }\nfunction isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\nfunction isEditable (el) {\n  if (!el) { return false; } // no parents were editable\n  if (el.contentEditable === 'false') { return false; } // stop the lookup\n  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl (el) {\n  return el.nextElementSibling || manually();\n  function manually () {\n    var sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n}\n\nfunction getEventHost (e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\n\nfunction getCoord (coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX', // IE8\n    pageY: 'clientY' // IE8\n  };\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n  return host[coord];\n}\n\nmodule.exports = dragula;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}