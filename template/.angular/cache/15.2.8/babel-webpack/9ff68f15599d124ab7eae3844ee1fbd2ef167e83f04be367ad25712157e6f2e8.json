{"ast":null,"code":"import * as dragulaExpt from 'dragula';\nimport dragulaExpt__default from 'dragula';\nimport { Injectable, Optional, Directive, Input, Output, ElementRef, EventEmitter, NgModule } from '@angular/core';\nimport { Subject, Subscription } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nclass Group {\n  /**\n   * @param {?} name\n   * @param {?} drake\n   * @param {?} options\n   */\n  constructor(name, drake, options) {\n    this.name = name;\n    this.drake = drake;\n    this.options = options;\n    this.initEvents = false;\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @enum {string} */\nconst EventTypes = {\n  Cancel: \"cancel\",\n  Cloned: \"cloned\",\n  Drag: \"drag\",\n  DragEnd: \"dragend\",\n  Drop: \"drop\",\n  Out: \"out\",\n  Over: \"over\",\n  Remove: \"remove\",\n  Shadow: \"shadow\",\n  DropModel: \"dropModel\",\n  RemoveModel: \"removeModel\"\n};\n/** @type {?} */\nconst AllEvents = Object.keys(EventTypes).map(k => /** @type {?} */EventTypes[/** @type {?} */k]);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst dragula = dragulaExpt__default || dragulaExpt;\nclass DrakeFactory {\n  /**\n   * @param {?=} build\n   */\n  constructor(build = dragula) {\n    this.build = build;\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst filterEvent = (eventType, filterDragType, projector) => input => {\n  return input.pipe(filter(({\n    event,\n    name\n  }) => {\n    return event === eventType && (filterDragType === undefined || name === filterDragType);\n  }), map(({\n    name,\n    args\n  }) => projector(name, args)));\n};\n/** @type {?} */\nconst elContainerSourceProjector = (name, [el, container, source]) => ({\n  name,\n  el,\n  container,\n  source\n});\nclass DragulaService {\n  /**\n   * @param {?=} drakeFactory\n   */\n  constructor(drakeFactory = null) {\n    this.drakeFactory = drakeFactory;\n    this.dispatch$ = new Subject();\n    this.drag = groupName => this.dispatch$.pipe(filterEvent(EventTypes.Drag, groupName, (name, [el, source]) => ({\n      name,\n      el,\n      source\n    })));\n    this.dragend = groupName => this.dispatch$.pipe(filterEvent(EventTypes.DragEnd, groupName, (name, [el]) => ({\n      name,\n      el\n    })));\n    this.drop = groupName => this.dispatch$.pipe(filterEvent(EventTypes.Drop, groupName, (name, [el, target, source, sibling]) => {\n      return {\n        name,\n        el,\n        target,\n        source,\n        sibling\n      };\n    }));\n    this.elContainerSource = eventType => groupName => this.dispatch$.pipe(filterEvent(eventType, groupName, elContainerSourceProjector));\n    this.cancel = this.elContainerSource(EventTypes.Cancel);\n    this.remove = this.elContainerSource(EventTypes.Remove);\n    this.shadow = this.elContainerSource(EventTypes.Shadow);\n    this.over = this.elContainerSource(EventTypes.Over);\n    this.out = this.elContainerSource(EventTypes.Out);\n    this.cloned = groupName => this.dispatch$.pipe(filterEvent(EventTypes.Cloned, groupName, (name, [clone, original, cloneType]) => {\n      return {\n        name,\n        clone,\n        original,\n        cloneType\n      };\n    }));\n    this.dropModel = groupName => this.dispatch$.pipe(filterEvent(EventTypes.DropModel, groupName, (name, [el, target, source, sibling, item, sourceModel, targetModel, sourceIndex, targetIndex]) => {\n      return {\n        name,\n        el,\n        target,\n        source,\n        sibling,\n        item,\n        sourceModel,\n        targetModel,\n        sourceIndex,\n        targetIndex\n      };\n    }));\n    this.removeModel = groupName => this.dispatch$.pipe(filterEvent(EventTypes.RemoveModel, groupName, (name, [el, container, source, item, sourceModel, sourceIndex]) => {\n      return {\n        name,\n        el,\n        container,\n        source,\n        item,\n        sourceModel,\n        sourceIndex\n      };\n    }));\n    this.groups = {};\n    if (this.drakeFactory === null) {\n      this.drakeFactory = new DrakeFactory();\n    }\n  }\n  /**\n   * Public mainly for testing purposes. Prefer `createGroup()`.\n   * @param {?} group\n   * @return {?}\n   */\n  add(group) {\n    /** @type {?} */\n    let existingGroup = this.find(group.name);\n    if (existingGroup) {\n      throw new Error('Group named: \"' + group.name + '\" already exists.');\n    }\n    this.groups[group.name] = group;\n    this.handleModels(group);\n    this.setupEvents(group);\n    return group;\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n  find(name) {\n    return this.groups[name];\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n  destroy(name) {\n    /** @type {?} */\n    let group = this.find(name);\n    if (!group) {\n      return;\n    }\n    group.drake && group.drake.destroy();\n    delete this.groups[name];\n  }\n  /**\n   * Creates a group with the specified name and options.\n   *\n   * Note: formerly known as `setOptions`\n   * @template T\n   * @param {?} name\n   * @param {?} options\n   * @return {?}\n   */\n  createGroup(name, options) {\n    return this.add(new Group(name, this.drakeFactory.build([], options), options));\n  }\n  /**\n   * @param {?} __0\n   * @return {?}\n   */\n  handleModels({\n    name,\n    drake,\n    options\n  }) {\n    /** @type {?} */\n    let dragElm;\n    /** @type {?} */\n    let dragIndex;\n    /** @type {?} */\n    let dropIndex;\n    drake.on('remove', (el, container, source) => {\n      if (!drake.models) {\n        return;\n      }\n      /** @type {?} */\n      let sourceModel = drake.models[drake.containers.indexOf(source)];\n      sourceModel = sourceModel.slice(0);\n      /** @type {?} */\n      const item = sourceModel.splice(dragIndex, 1)[0];\n      // console.log('REMOVE');\n      // console.log(sourceModel);\n      this.dispatch$.next({\n        event: EventTypes.RemoveModel,\n        name,\n        args: [el, container, source, item, sourceModel, dragIndex]\n      });\n    });\n    drake.on('drag', (el, source) => {\n      if (!drake.models) {\n        return;\n      }\n      dragElm = el;\n      dragIndex = this.domIndexOf(el, source);\n    });\n    drake.on('drop', (dropElm, target, source, sibling) => {\n      if (!drake.models || !target) {\n        return;\n      }\n      dropIndex = this.domIndexOf(dropElm, target);\n      /** @type {?} */\n      let sourceModel = drake.models[drake.containers.indexOf(source)];\n      /** @type {?} */\n      let targetModel = drake.models[drake.containers.indexOf(target)];\n      /** @type {?} */\n      let item;\n      if (target === source) {\n        sourceModel = sourceModel.slice(0);\n        item = sourceModel.splice(dragIndex, 1)[0];\n        sourceModel.splice(dropIndex, 0, item);\n        // this was true before we cloned and updated sourceModel,\n        // but targetModel still has the old value\n        targetModel = sourceModel;\n      } else {\n        /** @type {?} */\n        let isCopying = dragElm !== dropElm;\n        item = sourceModel[dragIndex];\n        if (isCopying) {\n          if (!options.copyItem) {\n            throw new Error(\"If you have enabled `copy` on a group, you must provide a `copyItem` function.\");\n          }\n          item = options.copyItem(item);\n        }\n        if (!isCopying) {\n          sourceModel = sourceModel.slice(0);\n          sourceModel.splice(dragIndex, 1);\n        }\n        targetModel = targetModel.slice(0);\n        targetModel.splice(dropIndex, 0, item);\n        if (isCopying) {\n          try {\n            target.removeChild(dropElm);\n          } catch (e) {}\n        }\n      }\n      this.dispatch$.next({\n        event: EventTypes.DropModel,\n        name,\n        args: [dropElm, target, source, sibling, item, sourceModel, targetModel, dragIndex, dropIndex]\n      });\n    });\n  }\n  /**\n   * @param {?} group\n   * @return {?}\n   */\n  setupEvents(group) {\n    if (group.initEvents) {\n      return;\n    }\n    group.initEvents = true;\n    /** @type {?} */\n    const name = group.name;\n    /** @type {?} */\n    let emitter = event => {\n      group.drake.on(event, (...args) => {\n        this.dispatch$.next({\n          event,\n          name,\n          args\n        });\n      });\n    };\n    AllEvents.forEach(emitter);\n  }\n  /**\n   * @param {?} child\n   * @param {?} parent\n   * @return {?}\n   */\n  domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(parent.children, child);\n  }\n}\nDragulaService.ɵfac = function DragulaService_Factory(t) {\n  return new (t || DragulaService)(ɵngcc0.ɵɵinject(DrakeFactory, 8));\n};\nDragulaService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DragulaService,\n  factory: DragulaService.ɵfac\n});\n/** @nocollapse */\nDragulaService.ctorParameters = () => [{\n  type: DrakeFactory,\n  decorators: [{\n    type: Optional\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DrakeFactory,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass DragulaDirective {\n  /**\n   * @param {?} el\n   * @param {?} dragulaService\n   */\n  constructor(el, dragulaService) {\n    this.el = el;\n    this.dragulaService = dragulaService;\n    this.dragulaModelChange = new EventEmitter();\n  }\n  /**\n   * @return {?}\n   */\n  get container() {\n    return this.el && this.el.nativeElement;\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n  ngOnChanges(changes) {\n    if (changes && changes.dragula) {\n      const {\n        previousValue: prev,\n        currentValue: current,\n        firstChange\n      } = changes.dragula;\n      /** @type {?} */\n      let hadPreviousValue = !!prev;\n      /** @type {?} */\n      let hasNewValue = !!current;\n      // something -> null       =>  teardown only\n      // something -> something  =>  teardown, then setup\n      //      null -> something  =>  setup only\n      //\n      //      null -> null (precluded by fact of change being present)\n      if (hadPreviousValue) {\n        this.teardown(prev);\n      }\n      if (hasNewValue) {\n        this.setup();\n      }\n    } else if (changes && changes.dragulaModel) {\n      const {\n        previousValue: prev,\n        currentValue: current,\n        firstChange\n      } = changes.dragulaModel;\n      const {\n        drake\n      } = this.group;\n      if (this.dragula && drake) {\n        drake.models = drake.models || [];\n        /** @type {?} */\n        let prevIndex = drake.models.indexOf(prev);\n        if (prevIndex !== -1) {\n          // delete the previous\n          drake.models.splice(prevIndex, 1);\n          // maybe insert a new one at the same spot\n          if (!!current) {\n            drake.models.splice(prevIndex, 0, current);\n          }\n        } else if (!!current) {\n          // no previous one to remove; just push this one.\n          drake.models.push(current);\n        }\n      }\n    }\n  }\n  /**\n   * @return {?}\n   */\n  setup() {\n    /** @type {?} */\n    let checkModel = group => {\n      if (this.dragulaModel) {\n        if (group.drake.models) {\n          group.drake.models.push(this.dragulaModel);\n        } else {\n          group.drake.models = [this.dragulaModel];\n        }\n      }\n    };\n    /** @type {?} */\n    let group = this.dragulaService.find(this.dragula);\n    if (!group) {\n      /** @type {?} */\n      let options = {};\n      group = this.dragulaService.createGroup(this.dragula, options);\n    }\n    // ensure model and container element are pushed\n    checkModel(group);\n    group.drake.containers.push(this.container);\n    this.subscribe(this.dragula);\n    this.group = group;\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n  subscribe(name) {\n    this.subs = new Subscription();\n    this.subs.add(this.dragulaService.dropModel(name).subscribe(({\n      source,\n      target,\n      sourceModel,\n      targetModel\n    }) => {\n      if (source === this.el.nativeElement) {\n        this.dragulaModelChange.emit(sourceModel);\n      } else if (target === this.el.nativeElement) {\n        this.dragulaModelChange.emit(targetModel);\n      }\n    }));\n    this.subs.add(this.dragulaService.removeModel(name).subscribe(({\n      source,\n      sourceModel\n    }) => {\n      if (source === this.el.nativeElement) {\n        this.dragulaModelChange.emit(sourceModel);\n      }\n    }));\n  }\n  /**\n   * @param {?} groupName\n   * @return {?}\n   */\n  teardown(groupName) {\n    if (this.subs) {\n      this.subs.unsubscribe();\n    }\n    /** @type {?} */\n    const group = this.dragulaService.find(groupName);\n    if (group) {\n      /** @type {?} */\n      const itemToRemove = group.drake.containers.indexOf(this.el.nativeElement);\n      if (itemToRemove !== -1) {\n        group.drake.containers.splice(itemToRemove, 1);\n      }\n      if (this.dragulaModel && group.drake && group.drake.models) {\n        /** @type {?} */\n        let modelIndex = group.drake.models.indexOf(this.dragulaModel);\n        if (modelIndex !== -1) {\n          group.drake.models.splice(modelIndex, 1);\n        }\n      }\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.teardown(this.dragula);\n  }\n}\nDragulaDirective.ɵfac = function DragulaDirective_Factory(t) {\n  return new (t || DragulaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragulaService));\n};\nDragulaDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DragulaDirective,\n  selectors: [[\"\", \"dragula\", \"\"]],\n  inputs: {\n    dragula: \"dragula\",\n    dragulaModel: \"dragulaModel\"\n  },\n  outputs: {\n    dragulaModelChange: \"dragulaModelChange\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\nDragulaDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: DragulaService\n}];\nDragulaDirective.propDecorators = {\n  dragula: [{\n    type: Input\n  }],\n  dragulaModel: [{\n    type: Input\n  }],\n  dragulaModelChange: [{\n    type: Output\n  }]\n};\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[dragula]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: DragulaService\n    }];\n  }, {\n    dragulaModelChange: [{\n      type: Output\n    }],\n    dragula: [{\n      type: Input\n    }],\n    dragulaModel: [{\n      type: Input\n    }]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass DragulaModule {\n  /**\n   * @return {?}\n   */\n  static forRoot() {\n    return {\n      ngModule: DragulaModule,\n      providers: [DragulaService]\n    };\n  }\n}\nDragulaModule.ɵfac = function DragulaModule_Factory(t) {\n  return new (t || DragulaModule)();\n};\nDragulaModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: DragulaModule\n});\nDragulaModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaModule, [{\n    type: NgModule,\n    args: [{\n      exports: [DragulaDirective],\n      declarations: [DragulaDirective]\n    }]\n  }], null, null);\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragulaModule, {\n    declarations: [DragulaDirective],\n    exports: [DragulaDirective]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst MockDrakeFactory = new DrakeFactory((containers, options) => {\n  return new MockDrake(containers, options);\n});\n/**\n * You can use MockDrake to simulate Drake events.\n *\n * The three methods that actually do anything are `on(event, listener)`,\n * `destroy()`, and a new method, `emit()`. Use `emit()` to manually emit Drake\n * events, and if you injected MockDrake properly with MockDrakeFactory or\n * mocked the DragulaService.find() method, then you can make ng2-dragula think\n * drags and drops are happening.\n *\n * Caveats:\n *\n * 1. YOU MUST MAKE THE DOM CHANGES YOURSELF.\n * 2. REPEAT: YOU MUST MAKE THE DOM CHANGES YOURSELF.\n *    That means `source.removeChild(el)`, and `target.insertBefore(el)`.\n * 3. None of the other methods do anything.\n *    That's ok, because ng2-dragula doesn't use them.\n */\nclass MockDrake {\n  /**\n   * @param {?=} containers A list of container elements.\n   * @param {?=} options These will NOT be used. At all.\n   * @param {?=} models Nonstandard, but useful for testing using `new MockDrake()` directly.\n   *               Note, default value is undefined, like a real Drake. Don't change that.\n   */\n  constructor(containers = [], options = {}, models) {\n    this.containers = containers;\n    this.options = options;\n    this.models = models;\n    /* Doesn't represent anything meaningful. */\n    this.dragging = false;\n    this.emitter$ = new Subject();\n    this.subs = new Subscription();\n  }\n  /**\n   * @param {?} item\n   * @return {?}\n   */\n  start(item) {\n    this.dragging = true;\n  }\n  /**\n   * @return {?}\n   */\n  end() {\n    this.dragging = false;\n  }\n  /**\n   * @param {?=} revert\n   * @return {?}\n   */\n  cancel(revert) {\n    this.dragging = false;\n  }\n  /**\n   * @return {?}\n   */\n  remove() {\n    this.dragging = false;\n  }\n  /**\n   * @param {?} event\n   * @param {?} callback\n   * @return {?}\n   */\n  on(event, callback) {\n    this.subs.add(this.emitter$.pipe(filter(({\n      eventType\n    }) => eventType === event)).subscribe(({\n      args\n    }) => {\n      callback(...args);\n    }));\n  }\n  /**\n   * @return {?}\n   */\n  destroy() {\n    this.subs.unsubscribe();\n  }\n  /**\n   * This is the most useful method. You can use it to manually fire events that would normally\n   * be fired by a real drake.\n   *\n   * You're likely most interested in firing `drag`, `remove` and `drop`, the three events\n   * DragulaService uses to implement [dragulaModel].\n   *\n   * See https://github.com/bevacqua/dragula#drakeon-events for what you should emit (and in what order).\n   *\n   * (Note also, firing dropModel and removeModel won't work. You would have to mock DragulaService for that.)\n   * @param {?} eventType\n   * @param {...?} args\n   * @return {?}\n   */\n  emit(eventType, ...args) {\n    this.emitter$.next({\n      eventType,\n      args\n    });\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { DragulaDirective, DragulaService, DragulaModule, dragula, DrakeFactory, Group, EventTypes, MockDrake, MockDrakeFactory };","map":{"version":3,"names":["dragulaExpt","dragulaExpt__default","Injectable","Optional","Directive","Input","Output","ElementRef","EventEmitter","NgModule","Subject","Subscription","filter","map","ɵngcc0","Group","constructor","name","drake","options","initEvents","EventTypes","Cancel","Cloned","Drag","DragEnd","Drop","Out","Over","Remove","Shadow","DropModel","RemoveModel","AllEvents","Object","keys","k","dragula","DrakeFactory","build","filterEvent","eventType","filterDragType","projector","input","pipe","event","undefined","args","elContainerSourceProjector","el","container","source","DragulaService","drakeFactory","dispatch$","drag","groupName","dragend","drop","target","sibling","elContainerSource","cancel","remove","shadow","over","out","cloned","clone","original","cloneType","dropModel","item","sourceModel","targetModel","sourceIndex","targetIndex","removeModel","groups","add","group","existingGroup","find","Error","handleModels","setupEvents","destroy","createGroup","dragElm","dragIndex","dropIndex","on","models","containers","indexOf","slice","splice","next","domIndexOf","dropElm","isCopying","copyItem","removeChild","e","emitter","forEach","child","parent","Array","prototype","call","children","ɵfac","DragulaService_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ctorParameters","type","decorators","ngDevMode","ɵsetClassMetadata","DragulaDirective","dragulaService","dragulaModelChange","nativeElement","ngOnChanges","changes","previousValue","prev","currentValue","current","firstChange","hadPreviousValue","hasNewValue","teardown","setup","dragulaModel","prevIndex","push","checkModel","subscribe","subs","emit","unsubscribe","itemToRemove","modelIndex","ngOnDestroy","DragulaDirective_Factory","ɵɵdirectiveInject","ɵdir","ɵɵdefineDirective","selectors","inputs","outputs","features","ɵɵNgOnChangesFeature","propDecorators","selector","DragulaModule","forRoot","ngModule","providers","DragulaModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","exports","declarations","ngJitMode","ɵɵsetNgModuleScope","MockDrakeFactory","MockDrake","dragging","emitter$","start","end","revert","callback"],"sources":["F:/Plantillas/template/node_modules/ng2-dragula/__ivy_ngcc__/dist/fesm2015/ng2-dragula.js"],"sourcesContent":["import * as dragulaExpt from 'dragula';\nimport dragulaExpt__default, {  } from 'dragula';\nimport { Injectable, Optional, Directive, Input, Output, ElementRef, EventEmitter, NgModule } from '@angular/core';\nimport { Subject, Subscription } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nclass Group {\n    /**\n     * @param {?} name\n     * @param {?} drake\n     * @param {?} options\n     */\n    constructor(name, drake, options) {\n        this.name = name;\n        this.drake = drake;\n        this.options = options;\n        this.initEvents = false;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @enum {string} */\nconst EventTypes = {\n    Cancel: \"cancel\",\n    Cloned: \"cloned\",\n    Drag: \"drag\",\n    DragEnd: \"dragend\",\n    Drop: \"drop\",\n    Out: \"out\",\n    Over: \"over\",\n    Remove: \"remove\",\n    Shadow: \"shadow\",\n    DropModel: \"dropModel\",\n    RemoveModel: \"removeModel\",\n};\n/** @type {?} */\nconst AllEvents = Object.keys(EventTypes).map(k => /** @type {?} */ (EventTypes[/** @type {?} */ (k)]));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst dragula = dragulaExpt__default || dragulaExpt;\nclass DrakeFactory {\n    /**\n     * @param {?=} build\n     */\n    constructor(build = dragula) {\n        this.build = build;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst filterEvent = (eventType, filterDragType, projector) => (input) => {\n    return input.pipe(filter(({ event, name }) => {\n        return event === eventType\n            && (filterDragType === undefined || name === filterDragType);\n    }), map(({ name, args }) => projector(name, args)));\n};\n/** @type {?} */\nconst elContainerSourceProjector = (name, [el, container, source]) => ({ name, el, container, source });\nclass DragulaService {\n    /**\n     * @param {?=} drakeFactory\n     */\n    constructor(drakeFactory = null) {\n        this.drakeFactory = drakeFactory;\n        this.dispatch$ = new Subject();\n        this.drag = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.Drag, groupName, (name, [el, source]) => ({ name, el, source })));\n        this.dragend = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.DragEnd, groupName, (name, [el]) => ({ name, el })));\n        this.drop = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.Drop, groupName, (name, [el, target, source, sibling]) => {\n            return { name, el, target, source, sibling };\n        }));\n        this.elContainerSource = (eventType) => (groupName) => this.dispatch$.pipe(filterEvent(eventType, groupName, elContainerSourceProjector));\n        this.cancel = this.elContainerSource(EventTypes.Cancel);\n        this.remove = this.elContainerSource(EventTypes.Remove);\n        this.shadow = this.elContainerSource(EventTypes.Shadow);\n        this.over = this.elContainerSource(EventTypes.Over);\n        this.out = this.elContainerSource(EventTypes.Out);\n        this.cloned = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.Cloned, groupName, (name, [clone, original, cloneType]) => {\n            return { name, clone, original, cloneType };\n        }));\n        this.dropModel = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.DropModel, groupName, (name, [el, target, source, sibling, item, sourceModel, targetModel, sourceIndex, targetIndex]) => {\n            return { name, el, target, source, sibling, item, sourceModel, targetModel, sourceIndex, targetIndex };\n        }));\n        this.removeModel = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.RemoveModel, groupName, (name, [el, container, source, item, sourceModel, sourceIndex]) => {\n            return { name, el, container, source, item, sourceModel, sourceIndex };\n        }));\n        this.groups = {};\n        if (this.drakeFactory === null) {\n            this.drakeFactory = new DrakeFactory();\n        }\n    }\n    /**\n     * Public mainly for testing purposes. Prefer `createGroup()`.\n     * @param {?} group\n     * @return {?}\n     */\n    add(group) {\n        /** @type {?} */\n        let existingGroup = this.find(group.name);\n        if (existingGroup) {\n            throw new Error('Group named: \"' + group.name + '\" already exists.');\n        }\n        this.groups[group.name] = group;\n        this.handleModels(group);\n        this.setupEvents(group);\n        return group;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    find(name) {\n        return this.groups[name];\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    destroy(name) {\n        /** @type {?} */\n        let group = this.find(name);\n        if (!group) {\n            return;\n        }\n        group.drake && group.drake.destroy();\n        delete this.groups[name];\n    }\n    /**\n     * Creates a group with the specified name and options.\n     *\n     * Note: formerly known as `setOptions`\n     * @template T\n     * @param {?} name\n     * @param {?} options\n     * @return {?}\n     */\n    createGroup(name, options) {\n        return this.add(new Group(name, this.drakeFactory.build([], options), options));\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    handleModels({ name, drake, options }) {\n        /** @type {?} */\n        let dragElm;\n        /** @type {?} */\n        let dragIndex;\n        /** @type {?} */\n        let dropIndex;\n        drake.on('remove', (el, container, source) => {\n            if (!drake.models) {\n                return;\n            }\n            /** @type {?} */\n            let sourceModel = drake.models[drake.containers.indexOf(source)];\n            sourceModel = sourceModel.slice(0);\n            /** @type {?} */\n            const item = sourceModel.splice(dragIndex, 1)[0];\n            // console.log('REMOVE');\n            // console.log(sourceModel);\n            this.dispatch$.next({\n                event: EventTypes.RemoveModel,\n                name,\n                args: [el, container, source, item, sourceModel, dragIndex]\n            });\n        });\n        drake.on('drag', (el, source) => {\n            if (!drake.models) {\n                return;\n            }\n            dragElm = el;\n            dragIndex = this.domIndexOf(el, source);\n        });\n        drake.on('drop', (dropElm, target, source, sibling) => {\n            if (!drake.models || !target) {\n                return;\n            }\n            dropIndex = this.domIndexOf(dropElm, target);\n            /** @type {?} */\n            let sourceModel = drake.models[drake.containers.indexOf(source)];\n            /** @type {?} */\n            let targetModel = drake.models[drake.containers.indexOf(target)];\n            /** @type {?} */\n            let item;\n            if (target === source) {\n                sourceModel = sourceModel.slice(0);\n                item = sourceModel.splice(dragIndex, 1)[0];\n                sourceModel.splice(dropIndex, 0, item);\n                // this was true before we cloned and updated sourceModel,\n                // but targetModel still has the old value\n                targetModel = sourceModel;\n            }\n            else {\n                /** @type {?} */\n                let isCopying = dragElm !== dropElm;\n                item = sourceModel[dragIndex];\n                if (isCopying) {\n                    if (!options.copyItem) {\n                        throw new Error(\"If you have enabled `copy` on a group, you must provide a `copyItem` function.\");\n                    }\n                    item = options.copyItem(item);\n                }\n                if (!isCopying) {\n                    sourceModel = sourceModel.slice(0);\n                    sourceModel.splice(dragIndex, 1);\n                }\n                targetModel = targetModel.slice(0);\n                targetModel.splice(dropIndex, 0, item);\n                if (isCopying) {\n                    try {\n                        target.removeChild(dropElm);\n                    }\n                    catch (e) { }\n                }\n            }\n            this.dispatch$.next({\n                event: EventTypes.DropModel,\n                name,\n                args: [dropElm, target, source, sibling, item, sourceModel, targetModel, dragIndex, dropIndex]\n            });\n        });\n    }\n    /**\n     * @param {?} group\n     * @return {?}\n     */\n    setupEvents(group) {\n        if (group.initEvents) {\n            return;\n        }\n        group.initEvents = true;\n        /** @type {?} */\n        const name = group.name;\n        /** @type {?} */\n        let emitter = (event) => {\n            group.drake.on(event, (...args) => {\n                this.dispatch$.next({ event, name, args });\n            });\n        };\n        AllEvents.forEach(emitter);\n    }\n    /**\n     * @param {?} child\n     * @param {?} parent\n     * @return {?}\n     */\n    domIndexOf(child, parent) {\n        return Array.prototype.indexOf.call(parent.children, child);\n    }\n}\nDragulaService.ɵfac = function DragulaService_Factory(t) { return new (t || DragulaService)(ɵngcc0.ɵɵinject(DrakeFactory, 8)); };\nDragulaService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DragulaService, factory: DragulaService.ɵfac });\n/** @nocollapse */\nDragulaService.ctorParameters = () => [\n    { type: DrakeFactory, decorators: [{ type: Optional }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaService, [{\n        type: Injectable\n    }], function () { return [{ type: DrakeFactory, decorators: [{\n                type: Optional\n            }] }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass DragulaDirective {\n    /**\n     * @param {?} el\n     * @param {?} dragulaService\n     */\n    constructor(el, dragulaService) {\n        this.el = el;\n        this.dragulaService = dragulaService;\n        this.dragulaModelChange = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    get container() {\n        return this.el && this.el.nativeElement;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes && changes.dragula) {\n            const { previousValue: prev, currentValue: current, firstChange } = changes.dragula;\n            /** @type {?} */\n            let hadPreviousValue = !!prev;\n            /** @type {?} */\n            let hasNewValue = !!current;\n            // something -> null       =>  teardown only\n            // something -> something  =>  teardown, then setup\n            //      null -> something  =>  setup only\n            //\n            //      null -> null (precluded by fact of change being present)\n            if (hadPreviousValue) {\n                this.teardown(prev);\n            }\n            if (hasNewValue) {\n                this.setup();\n            }\n        }\n        else if (changes && changes.dragulaModel) {\n            const { previousValue: prev, currentValue: current, firstChange } = changes.dragulaModel;\n            const { drake } = this.group;\n            if (this.dragula && drake) {\n                drake.models = drake.models || [];\n                /** @type {?} */\n                let prevIndex = drake.models.indexOf(prev);\n                if (prevIndex !== -1) {\n                    // delete the previous\n                    drake.models.splice(prevIndex, 1);\n                    // maybe insert a new one at the same spot\n                    if (!!current) {\n                        drake.models.splice(prevIndex, 0, current);\n                    }\n                }\n                else if (!!current) {\n                    // no previous one to remove; just push this one.\n                    drake.models.push(current);\n                }\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    setup() {\n        /** @type {?} */\n        let checkModel = (group) => {\n            if (this.dragulaModel) {\n                if (group.drake.models) {\n                    group.drake.models.push(this.dragulaModel);\n                }\n                else {\n                    group.drake.models = [this.dragulaModel];\n                }\n            }\n        };\n        /** @type {?} */\n        let group = this.dragulaService.find(this.dragula);\n        if (!group) {\n            /** @type {?} */\n            let options = {};\n            group = this.dragulaService.createGroup(this.dragula, options);\n        }\n        // ensure model and container element are pushed\n        checkModel(group);\n        group.drake.containers.push(this.container);\n        this.subscribe(this.dragula);\n        this.group = group;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    subscribe(name) {\n        this.subs = new Subscription();\n        this.subs.add(this.dragulaService\n            .dropModel(name)\n            .subscribe(({ source, target, sourceModel, targetModel }) => {\n            if (source === this.el.nativeElement) {\n                this.dragulaModelChange.emit(sourceModel);\n            }\n            else if (target === this.el.nativeElement) {\n                this.dragulaModelChange.emit(targetModel);\n            }\n        }));\n        this.subs.add(this.dragulaService\n            .removeModel(name)\n            .subscribe(({ source, sourceModel }) => {\n            if (source === this.el.nativeElement) {\n                this.dragulaModelChange.emit(sourceModel);\n            }\n        }));\n    }\n    /**\n     * @param {?} groupName\n     * @return {?}\n     */\n    teardown(groupName) {\n        if (this.subs) {\n            this.subs.unsubscribe();\n        }\n        /** @type {?} */\n        const group = this.dragulaService.find(groupName);\n        if (group) {\n            /** @type {?} */\n            const itemToRemove = group.drake.containers.indexOf(this.el.nativeElement);\n            if (itemToRemove !== -1) {\n                group.drake.containers.splice(itemToRemove, 1);\n            }\n            if (this.dragulaModel && group.drake && group.drake.models) {\n                /** @type {?} */\n                let modelIndex = group.drake.models.indexOf(this.dragulaModel);\n                if (modelIndex !== -1) {\n                    group.drake.models.splice(modelIndex, 1);\n                }\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.teardown(this.dragula);\n    }\n}\nDragulaDirective.ɵfac = function DragulaDirective_Factory(t) { return new (t || DragulaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragulaService)); };\nDragulaDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DragulaDirective, selectors: [[\"\", \"dragula\", \"\"]], inputs: { dragula: \"dragula\", dragulaModel: \"dragulaModel\" }, outputs: { dragulaModelChange: \"dragulaModelChange\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\n/** @nocollapse */\nDragulaDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DragulaService }\n];\nDragulaDirective.propDecorators = {\n    dragula: [{ type: Input }],\n    dragulaModel: [{ type: Input }],\n    dragulaModelChange: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaDirective, [{\n        type: Directive,\n        args: [{ selector: '[dragula]' }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DragulaService }]; }, { dragulaModelChange: [{\n            type: Output\n        }], dragula: [{\n            type: Input\n        }], dragulaModel: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass DragulaModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n        return {\n            ngModule: DragulaModule,\n            providers: [DragulaService]\n        };\n    }\n}\nDragulaModule.ɵfac = function DragulaModule_Factory(t) { return new (t || DragulaModule)(); };\nDragulaModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DragulaModule });\nDragulaModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaModule, [{\n        type: NgModule,\n        args: [{\n                exports: [DragulaDirective],\n                declarations: [DragulaDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragulaModule, { declarations: [DragulaDirective], exports: [DragulaDirective] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst MockDrakeFactory = new DrakeFactory((containers, options) => {\n    return new MockDrake(containers, options);\n});\n/**\n * You can use MockDrake to simulate Drake events.\n *\n * The three methods that actually do anything are `on(event, listener)`,\n * `destroy()`, and a new method, `emit()`. Use `emit()` to manually emit Drake\n * events, and if you injected MockDrake properly with MockDrakeFactory or\n * mocked the DragulaService.find() method, then you can make ng2-dragula think\n * drags and drops are happening.\n *\n * Caveats:\n *\n * 1. YOU MUST MAKE THE DOM CHANGES YOURSELF.\n * 2. REPEAT: YOU MUST MAKE THE DOM CHANGES YOURSELF.\n *    That means `source.removeChild(el)`, and `target.insertBefore(el)`.\n * 3. None of the other methods do anything.\n *    That's ok, because ng2-dragula doesn't use them.\n */\nclass MockDrake {\n    /**\n     * @param {?=} containers A list of container elements.\n     * @param {?=} options These will NOT be used. At all.\n     * @param {?=} models Nonstandard, but useful for testing using `new MockDrake()` directly.\n     *               Note, default value is undefined, like a real Drake. Don't change that.\n     */\n    constructor(containers = [], options = {}, models) {\n        this.containers = containers;\n        this.options = options;\n        this.models = models;\n        /* Doesn't represent anything meaningful. */\n        this.dragging = false;\n        this.emitter$ = new Subject();\n        this.subs = new Subscription();\n    }\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    start(item) {\n        this.dragging = true;\n    }\n    /**\n     * @return {?}\n     */\n    end() {\n        this.dragging = false;\n    }\n    /**\n     * @param {?=} revert\n     * @return {?}\n     */\n    cancel(revert) {\n        this.dragging = false;\n    }\n    /**\n     * @return {?}\n     */\n    remove() {\n        this.dragging = false;\n    }\n    /**\n     * @param {?} event\n     * @param {?} callback\n     * @return {?}\n     */\n    on(event, callback) {\n        this.subs.add(this.emitter$\n            .pipe(filter(({ eventType }) => eventType === event))\n            .subscribe(({ args }) => {\n            callback(...args);\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    destroy() {\n        this.subs.unsubscribe();\n    }\n    /**\n     * This is the most useful method. You can use it to manually fire events that would normally\n     * be fired by a real drake.\n     *\n     * You're likely most interested in firing `drag`, `remove` and `drop`, the three events\n     * DragulaService uses to implement [dragulaModel].\n     *\n     * See https://github.com/bevacqua/dragula#drakeon-events for what you should emit (and in what order).\n     *\n     * (Note also, firing dropModel and removeModel won't work. You would have to mock DragulaService for that.)\n     * @param {?} eventType\n     * @param {...?} args\n     * @return {?}\n     */\n    emit(eventType, ...args) {\n        this.emitter$.next({ eventType, args });\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { DragulaDirective, DragulaService, DragulaModule, dragula, DrakeFactory, Group, EventTypes, MockDrake, MockDrakeFactory };\n\n"],"mappings":"AAAA,OAAO,KAAKA,WAAW,MAAM,SAAS;AACtC,OAAOC,oBAAoB,MAAY,SAAS;AAChD,SAASC,UAAU,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,KAAK,EAAEC,MAAM,EAAEC,UAAU,EAAEC,YAAY,EAAEC,QAAQ,QAAQ,eAAe;AAClH,SAASC,OAAO,EAAEC,YAAY,QAAQ,MAAM;AAC5C,SAASC,MAAM,EAAEC,GAAG,QAAQ,gBAAgB;;AAE5C;AACA;AACA;AACA;AACA,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,MAAMC,KAAK,CAAC;EACR;AACJ;AACA;AACA;AACA;EACIC,WAAW,CAACC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;IAC9B,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,UAAU,GAAG,KAAK;EAC3B;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,MAAM;EACZC,OAAO,EAAE,SAAS;EAClBC,IAAI,EAAE,MAAM;EACZC,GAAG,EAAE,KAAK;EACVC,IAAI,EAAE,MAAM;EACZC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,SAAS,EAAE,WAAW;EACtBC,WAAW,EAAE;AACjB,CAAC;AACD;AACA,MAAMC,SAAS,GAAGC,MAAM,CAACC,IAAI,CAACd,UAAU,CAAC,CAACR,GAAG,CAACuB,CAAC,IAAI,gBAAkBf,UAAU,CAAC,gBAAkBe,CAAC,CAAG,CAAC;;AAEvG;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAGpC,oBAAoB,IAAID,WAAW;AACnD,MAAMsC,YAAY,CAAC;EACf;AACJ;AACA;EACItB,WAAW,CAACuB,KAAK,GAAGF,OAAO,EAAE;IACzB,IAAI,CAACE,KAAK,GAAGA,KAAK;EACtB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAG,CAACC,SAAS,EAAEC,cAAc,EAAEC,SAAS,KAAMC,KAAK,IAAK;EACrE,OAAOA,KAAK,CAACC,IAAI,CAACjC,MAAM,CAAC,CAAC;IAAEkC,KAAK;IAAE7B;EAAK,CAAC,KAAK;IAC1C,OAAO6B,KAAK,KAAKL,SAAS,KAClBC,cAAc,KAAKK,SAAS,IAAI9B,IAAI,KAAKyB,cAAc,CAAC;EACpE,CAAC,CAAC,EAAE7B,GAAG,CAAC,CAAC;IAAEI,IAAI;IAAE+B;EAAK,CAAC,KAAKL,SAAS,CAAC1B,IAAI,EAAE+B,IAAI,CAAC,CAAC,CAAC;AACvD,CAAC;AACD;AACA,MAAMC,0BAA0B,GAAG,CAAChC,IAAI,EAAE,CAACiC,EAAE,EAAEC,SAAS,EAAEC,MAAM,CAAC,MAAM;EAAEnC,IAAI;EAAEiC,EAAE;EAAEC,SAAS;EAAEC;AAAO,CAAC,CAAC;AACvG,MAAMC,cAAc,CAAC;EACjB;AACJ;AACA;EACIrC,WAAW,CAACsC,YAAY,GAAG,IAAI,EAAE;IAC7B,IAAI,CAACA,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,SAAS,GAAG,IAAI7C,OAAO,EAAE;IAC9B,IAAI,CAAC8C,IAAI,GAAIC,SAAS,IAAK,IAAI,CAACF,SAAS,CAACV,IAAI,CAACL,WAAW,CAACnB,UAAU,CAACG,IAAI,EAAEiC,SAAS,EAAE,CAACxC,IAAI,EAAE,CAACiC,EAAE,EAAEE,MAAM,CAAC,MAAM;MAAEnC,IAAI;MAAEiC,EAAE;MAAEE;IAAO,CAAC,CAAC,CAAC,CAAC;IACvI,IAAI,CAACM,OAAO,GAAID,SAAS,IAAK,IAAI,CAACF,SAAS,CAACV,IAAI,CAACL,WAAW,CAACnB,UAAU,CAACI,OAAO,EAAEgC,SAAS,EAAE,CAACxC,IAAI,EAAE,CAACiC,EAAE,CAAC,MAAM;MAAEjC,IAAI;MAAEiC;IAAG,CAAC,CAAC,CAAC,CAAC;IAC7H,IAAI,CAACS,IAAI,GAAIF,SAAS,IAAK,IAAI,CAACF,SAAS,CAACV,IAAI,CAACL,WAAW,CAACnB,UAAU,CAACK,IAAI,EAAE+B,SAAS,EAAE,CAACxC,IAAI,EAAE,CAACiC,EAAE,EAAEU,MAAM,EAAER,MAAM,EAAES,OAAO,CAAC,KAAK;MAC5H,OAAO;QAAE5C,IAAI;QAAEiC,EAAE;QAAEU,MAAM;QAAER,MAAM;QAAES;MAAQ,CAAC;IAChD,CAAC,CAAC,CAAC;IACH,IAAI,CAACC,iBAAiB,GAAIrB,SAAS,IAAMgB,SAAS,IAAK,IAAI,CAACF,SAAS,CAACV,IAAI,CAACL,WAAW,CAACC,SAAS,EAAEgB,SAAS,EAAER,0BAA0B,CAAC,CAAC;IACzI,IAAI,CAACc,MAAM,GAAG,IAAI,CAACD,iBAAiB,CAACzC,UAAU,CAACC,MAAM,CAAC;IACvD,IAAI,CAAC0C,MAAM,GAAG,IAAI,CAACF,iBAAiB,CAACzC,UAAU,CAACQ,MAAM,CAAC;IACvD,IAAI,CAACoC,MAAM,GAAG,IAAI,CAACH,iBAAiB,CAACzC,UAAU,CAACS,MAAM,CAAC;IACvD,IAAI,CAACoC,IAAI,GAAG,IAAI,CAACJ,iBAAiB,CAACzC,UAAU,CAACO,IAAI,CAAC;IACnD,IAAI,CAACuC,GAAG,GAAG,IAAI,CAACL,iBAAiB,CAACzC,UAAU,CAACM,GAAG,CAAC;IACjD,IAAI,CAACyC,MAAM,GAAIX,SAAS,IAAK,IAAI,CAACF,SAAS,CAACV,IAAI,CAACL,WAAW,CAACnB,UAAU,CAACE,MAAM,EAAEkC,SAAS,EAAE,CAACxC,IAAI,EAAE,CAACoD,KAAK,EAAEC,QAAQ,EAAEC,SAAS,CAAC,KAAK;MAC/H,OAAO;QAAEtD,IAAI;QAAEoD,KAAK;QAAEC,QAAQ;QAAEC;MAAU,CAAC;IAC/C,CAAC,CAAC,CAAC;IACH,IAAI,CAACC,SAAS,GAAIf,SAAS,IAAK,IAAI,CAACF,SAAS,CAACV,IAAI,CAACL,WAAW,CAACnB,UAAU,CAACU,SAAS,EAAE0B,SAAS,EAAE,CAACxC,IAAI,EAAE,CAACiC,EAAE,EAAEU,MAAM,EAAER,MAAM,EAAES,OAAO,EAAEY,IAAI,EAAEC,WAAW,EAAEC,WAAW,EAAEC,WAAW,EAAEC,WAAW,CAAC,KAAK;MAChM,OAAO;QAAE5D,IAAI;QAAEiC,EAAE;QAAEU,MAAM;QAAER,MAAM;QAAES,OAAO;QAAEY,IAAI;QAAEC,WAAW;QAAEC,WAAW;QAAEC,WAAW;QAAEC;MAAY,CAAC;IAC1G,CAAC,CAAC,CAAC;IACH,IAAI,CAACC,WAAW,GAAIrB,SAAS,IAAK,IAAI,CAACF,SAAS,CAACV,IAAI,CAACL,WAAW,CAACnB,UAAU,CAACW,WAAW,EAAEyB,SAAS,EAAE,CAACxC,IAAI,EAAE,CAACiC,EAAE,EAAEC,SAAS,EAAEC,MAAM,EAAEqB,IAAI,EAAEC,WAAW,EAAEE,WAAW,CAAC,KAAK;MACpK,OAAO;QAAE3D,IAAI;QAAEiC,EAAE;QAAEC,SAAS;QAAEC,MAAM;QAAEqB,IAAI;QAAEC,WAAW;QAAEE;MAAY,CAAC;IAC1E,CAAC,CAAC,CAAC;IACH,IAAI,CAACG,MAAM,GAAG,CAAC,CAAC;IAChB,IAAI,IAAI,CAACzB,YAAY,KAAK,IAAI,EAAE;MAC5B,IAAI,CAACA,YAAY,GAAG,IAAIhB,YAAY,EAAE;IAC1C;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI0C,GAAG,CAACC,KAAK,EAAE;IACP;IACA,IAAIC,aAAa,GAAG,IAAI,CAACC,IAAI,CAACF,KAAK,CAAChE,IAAI,CAAC;IACzC,IAAIiE,aAAa,EAAE;MACf,MAAM,IAAIE,KAAK,CAAC,gBAAgB,GAAGH,KAAK,CAAChE,IAAI,GAAG,mBAAmB,CAAC;IACxE;IACA,IAAI,CAAC8D,MAAM,CAACE,KAAK,CAAChE,IAAI,CAAC,GAAGgE,KAAK;IAC/B,IAAI,CAACI,YAAY,CAACJ,KAAK,CAAC;IACxB,IAAI,CAACK,WAAW,CAACL,KAAK,CAAC;IACvB,OAAOA,KAAK;EAChB;EACA;AACJ;AACA;AACA;EACIE,IAAI,CAAClE,IAAI,EAAE;IACP,OAAO,IAAI,CAAC8D,MAAM,CAAC9D,IAAI,CAAC;EAC5B;EACA;AACJ;AACA;AACA;EACIsE,OAAO,CAACtE,IAAI,EAAE;IACV;IACA,IAAIgE,KAAK,GAAG,IAAI,CAACE,IAAI,CAAClE,IAAI,CAAC;IAC3B,IAAI,CAACgE,KAAK,EAAE;MACR;IACJ;IACAA,KAAK,CAAC/D,KAAK,IAAI+D,KAAK,CAAC/D,KAAK,CAACqE,OAAO,EAAE;IACpC,OAAO,IAAI,CAACR,MAAM,CAAC9D,IAAI,CAAC;EAC5B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIuE,WAAW,CAACvE,IAAI,EAAEE,OAAO,EAAE;IACvB,OAAO,IAAI,CAAC6D,GAAG,CAAC,IAAIjE,KAAK,CAACE,IAAI,EAAE,IAAI,CAACqC,YAAY,CAACf,KAAK,CAAC,EAAE,EAAEpB,OAAO,CAAC,EAAEA,OAAO,CAAC,CAAC;EACnF;EACA;AACJ;AACA;AACA;EACIkE,YAAY,CAAC;IAAEpE,IAAI;IAAEC,KAAK;IAAEC;EAAQ,CAAC,EAAE;IACnC;IACA,IAAIsE,OAAO;IACX;IACA,IAAIC,SAAS;IACb;IACA,IAAIC,SAAS;IACbzE,KAAK,CAAC0E,EAAE,CAAC,QAAQ,EAAE,CAAC1C,EAAE,EAAEC,SAAS,EAAEC,MAAM,KAAK;MAC1C,IAAI,CAAClC,KAAK,CAAC2E,MAAM,EAAE;QACf;MACJ;MACA;MACA,IAAInB,WAAW,GAAGxD,KAAK,CAAC2E,MAAM,CAAC3E,KAAK,CAAC4E,UAAU,CAACC,OAAO,CAAC3C,MAAM,CAAC,CAAC;MAChEsB,WAAW,GAAGA,WAAW,CAACsB,KAAK,CAAC,CAAC,CAAC;MAClC;MACA,MAAMvB,IAAI,GAAGC,WAAW,CAACuB,MAAM,CAACP,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;MAChD;MACA;MACA,IAAI,CAACnC,SAAS,CAAC2C,IAAI,CAAC;QAChBpD,KAAK,EAAEzB,UAAU,CAACW,WAAW;QAC7Bf,IAAI;QACJ+B,IAAI,EAAE,CAACE,EAAE,EAAEC,SAAS,EAAEC,MAAM,EAAEqB,IAAI,EAAEC,WAAW,EAAEgB,SAAS;MAC9D,CAAC,CAAC;IACN,CAAC,CAAC;IACFxE,KAAK,CAAC0E,EAAE,CAAC,MAAM,EAAE,CAAC1C,EAAE,EAAEE,MAAM,KAAK;MAC7B,IAAI,CAAClC,KAAK,CAAC2E,MAAM,EAAE;QACf;MACJ;MACAJ,OAAO,GAAGvC,EAAE;MACZwC,SAAS,GAAG,IAAI,CAACS,UAAU,CAACjD,EAAE,EAAEE,MAAM,CAAC;IAC3C,CAAC,CAAC;IACFlC,KAAK,CAAC0E,EAAE,CAAC,MAAM,EAAE,CAACQ,OAAO,EAAExC,MAAM,EAAER,MAAM,EAAES,OAAO,KAAK;MACnD,IAAI,CAAC3C,KAAK,CAAC2E,MAAM,IAAI,CAACjC,MAAM,EAAE;QAC1B;MACJ;MACA+B,SAAS,GAAG,IAAI,CAACQ,UAAU,CAACC,OAAO,EAAExC,MAAM,CAAC;MAC5C;MACA,IAAIc,WAAW,GAAGxD,KAAK,CAAC2E,MAAM,CAAC3E,KAAK,CAAC4E,UAAU,CAACC,OAAO,CAAC3C,MAAM,CAAC,CAAC;MAChE;MACA,IAAIuB,WAAW,GAAGzD,KAAK,CAAC2E,MAAM,CAAC3E,KAAK,CAAC4E,UAAU,CAACC,OAAO,CAACnC,MAAM,CAAC,CAAC;MAChE;MACA,IAAIa,IAAI;MACR,IAAIb,MAAM,KAAKR,MAAM,EAAE;QACnBsB,WAAW,GAAGA,WAAW,CAACsB,KAAK,CAAC,CAAC,CAAC;QAClCvB,IAAI,GAAGC,WAAW,CAACuB,MAAM,CAACP,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1ChB,WAAW,CAACuB,MAAM,CAACN,SAAS,EAAE,CAAC,EAAElB,IAAI,CAAC;QACtC;QACA;QACAE,WAAW,GAAGD,WAAW;MAC7B,CAAC,MACI;QACD;QACA,IAAI2B,SAAS,GAAGZ,OAAO,KAAKW,OAAO;QACnC3B,IAAI,GAAGC,WAAW,CAACgB,SAAS,CAAC;QAC7B,IAAIW,SAAS,EAAE;UACX,IAAI,CAAClF,OAAO,CAACmF,QAAQ,EAAE;YACnB,MAAM,IAAIlB,KAAK,CAAC,gFAAgF,CAAC;UACrG;UACAX,IAAI,GAAGtD,OAAO,CAACmF,QAAQ,CAAC7B,IAAI,CAAC;QACjC;QACA,IAAI,CAAC4B,SAAS,EAAE;UACZ3B,WAAW,GAAGA,WAAW,CAACsB,KAAK,CAAC,CAAC,CAAC;UAClCtB,WAAW,CAACuB,MAAM,CAACP,SAAS,EAAE,CAAC,CAAC;QACpC;QACAf,WAAW,GAAGA,WAAW,CAACqB,KAAK,CAAC,CAAC,CAAC;QAClCrB,WAAW,CAACsB,MAAM,CAACN,SAAS,EAAE,CAAC,EAAElB,IAAI,CAAC;QACtC,IAAI4B,SAAS,EAAE;UACX,IAAI;YACAzC,MAAM,CAAC2C,WAAW,CAACH,OAAO,CAAC;UAC/B,CAAC,CACD,OAAOI,CAAC,EAAE,CAAE;QAChB;MACJ;MACA,IAAI,CAACjD,SAAS,CAAC2C,IAAI,CAAC;QAChBpD,KAAK,EAAEzB,UAAU,CAACU,SAAS;QAC3Bd,IAAI;QACJ+B,IAAI,EAAE,CAACoD,OAAO,EAAExC,MAAM,EAAER,MAAM,EAAES,OAAO,EAAEY,IAAI,EAAEC,WAAW,EAAEC,WAAW,EAAEe,SAAS,EAAEC,SAAS;MACjG,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;EACIL,WAAW,CAACL,KAAK,EAAE;IACf,IAAIA,KAAK,CAAC7D,UAAU,EAAE;MAClB;IACJ;IACA6D,KAAK,CAAC7D,UAAU,GAAG,IAAI;IACvB;IACA,MAAMH,IAAI,GAAGgE,KAAK,CAAChE,IAAI;IACvB;IACA,IAAIwF,OAAO,GAAI3D,KAAK,IAAK;MACrBmC,KAAK,CAAC/D,KAAK,CAAC0E,EAAE,CAAC9C,KAAK,EAAE,CAAC,GAAGE,IAAI,KAAK;QAC/B,IAAI,CAACO,SAAS,CAAC2C,IAAI,CAAC;UAAEpD,KAAK;UAAE7B,IAAI;UAAE+B;QAAK,CAAC,CAAC;MAC9C,CAAC,CAAC;IACN,CAAC;IACDf,SAAS,CAACyE,OAAO,CAACD,OAAO,CAAC;EAC9B;EACA;AACJ;AACA;AACA;AACA;EACIN,UAAU,CAACQ,KAAK,EAAEC,MAAM,EAAE;IACtB,OAAOC,KAAK,CAACC,SAAS,CAACf,OAAO,CAACgB,IAAI,CAACH,MAAM,CAACI,QAAQ,EAAEL,KAAK,CAAC;EAC/D;AACJ;AACAtD,cAAc,CAAC4D,IAAI,GAAG,SAASC,sBAAsB,CAACC,CAAC,EAAE;EAAE,OAAO,KAAKA,CAAC,IAAI9D,cAAc,EAAEvC,MAAM,CAACsG,QAAQ,CAAC9E,YAAY,EAAE,CAAC,CAAC,CAAC;AAAE,CAAC;AAChIe,cAAc,CAACgE,KAAK,GAAG,aAAcvG,MAAM,CAACwG,kBAAkB,CAAC;EAAEC,KAAK,EAAElE,cAAc;EAAEmE,OAAO,EAAEnE,cAAc,CAAC4D;AAAK,CAAC,CAAC;AACvH;AACA5D,cAAc,CAACoE,cAAc,GAAG,MAAM,CAClC;EAAEC,IAAI,EAAEpF,YAAY;EAAEqF,UAAU,EAAE,CAAC;IAAED,IAAI,EAAEvH;EAAS,CAAC;AAAE,CAAC,CAC3D;AACD,CAAC,YAAY;EAAE,CAAC,OAAOyH,SAAS,KAAK,WAAW,IAAIA,SAAS,KAAK9G,MAAM,CAAC+G,iBAAiB,CAACxE,cAAc,EAAE,CAAC;IACpGqE,IAAI,EAAExH;EACV,CAAC,CAAC,EAAE,YAAY;IAAE,OAAO,CAAC;MAAEwH,IAAI,EAAEpF,YAAY;MAAEqF,UAAU,EAAE,CAAC;QACjDD,IAAI,EAAEvH;MACV,CAAC;IAAE,CAAC,CAAC;EAAE,CAAC,EAAE,IAAI,CAAC;AAAE,CAAC,GAAG;;AAEjC;AACA;AACA;AACA;AACA,MAAM2H,gBAAgB,CAAC;EACnB;AACJ;AACA;AACA;EACI9G,WAAW,CAACkC,EAAE,EAAE6E,cAAc,EAAE;IAC5B,IAAI,CAAC7E,EAAE,GAAGA,EAAE;IACZ,IAAI,CAAC6E,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,kBAAkB,GAAG,IAAIxH,YAAY,EAAE;EAChD;EACA;AACJ;AACA;EACI,IAAI2C,SAAS,GAAG;IACZ,OAAO,IAAI,CAACD,EAAE,IAAI,IAAI,CAACA,EAAE,CAAC+E,aAAa;EAC3C;EACA;AACJ;AACA;AACA;EACIC,WAAW,CAACC,OAAO,EAAE;IACjB,IAAIA,OAAO,IAAIA,OAAO,CAAC9F,OAAO,EAAE;MAC5B,MAAM;QAAE+F,aAAa,EAAEC,IAAI;QAAEC,YAAY,EAAEC,OAAO;QAAEC;MAAY,CAAC,GAAGL,OAAO,CAAC9F,OAAO;MACnF;MACA,IAAIoG,gBAAgB,GAAG,CAAC,CAACJ,IAAI;MAC7B;MACA,IAAIK,WAAW,GAAG,CAAC,CAACH,OAAO;MAC3B;MACA;MACA;MACA;MACA;MACA,IAAIE,gBAAgB,EAAE;QAClB,IAAI,CAACE,QAAQ,CAACN,IAAI,CAAC;MACvB;MACA,IAAIK,WAAW,EAAE;QACb,IAAI,CAACE,KAAK,EAAE;MAChB;IACJ,CAAC,MACI,IAAIT,OAAO,IAAIA,OAAO,CAACU,YAAY,EAAE;MACtC,MAAM;QAAET,aAAa,EAAEC,IAAI;QAAEC,YAAY,EAAEC,OAAO;QAAEC;MAAY,CAAC,GAAGL,OAAO,CAACU,YAAY;MACxF,MAAM;QAAE3H;MAAM,CAAC,GAAG,IAAI,CAAC+D,KAAK;MAC5B,IAAI,IAAI,CAAC5C,OAAO,IAAInB,KAAK,EAAE;QACvBA,KAAK,CAAC2E,MAAM,GAAG3E,KAAK,CAAC2E,MAAM,IAAI,EAAE;QACjC;QACA,IAAIiD,SAAS,GAAG5H,KAAK,CAAC2E,MAAM,CAACE,OAAO,CAACsC,IAAI,CAAC;QAC1C,IAAIS,SAAS,KAAK,CAAC,CAAC,EAAE;UAClB;UACA5H,KAAK,CAAC2E,MAAM,CAACI,MAAM,CAAC6C,SAAS,EAAE,CAAC,CAAC;UACjC;UACA,IAAI,CAAC,CAACP,OAAO,EAAE;YACXrH,KAAK,CAAC2E,MAAM,CAACI,MAAM,CAAC6C,SAAS,EAAE,CAAC,EAAEP,OAAO,CAAC;UAC9C;QACJ,CAAC,MACI,IAAI,CAAC,CAACA,OAAO,EAAE;UAChB;UACArH,KAAK,CAAC2E,MAAM,CAACkD,IAAI,CAACR,OAAO,CAAC;QAC9B;MACJ;IACJ;EACJ;EACA;AACJ;AACA;EACIK,KAAK,GAAG;IACJ;IACA,IAAII,UAAU,GAAI/D,KAAK,IAAK;MACxB,IAAI,IAAI,CAAC4D,YAAY,EAAE;QACnB,IAAI5D,KAAK,CAAC/D,KAAK,CAAC2E,MAAM,EAAE;UACpBZ,KAAK,CAAC/D,KAAK,CAAC2E,MAAM,CAACkD,IAAI,CAAC,IAAI,CAACF,YAAY,CAAC;QAC9C,CAAC,MACI;UACD5D,KAAK,CAAC/D,KAAK,CAAC2E,MAAM,GAAG,CAAC,IAAI,CAACgD,YAAY,CAAC;QAC5C;MACJ;IACJ,CAAC;IACD;IACA,IAAI5D,KAAK,GAAG,IAAI,CAAC8C,cAAc,CAAC5C,IAAI,CAAC,IAAI,CAAC9C,OAAO,CAAC;IAClD,IAAI,CAAC4C,KAAK,EAAE;MACR;MACA,IAAI9D,OAAO,GAAG,CAAC,CAAC;MAChB8D,KAAK,GAAG,IAAI,CAAC8C,cAAc,CAACvC,WAAW,CAAC,IAAI,CAACnD,OAAO,EAAElB,OAAO,CAAC;IAClE;IACA;IACA6H,UAAU,CAAC/D,KAAK,CAAC;IACjBA,KAAK,CAAC/D,KAAK,CAAC4E,UAAU,CAACiD,IAAI,CAAC,IAAI,CAAC5F,SAAS,CAAC;IAC3C,IAAI,CAAC8F,SAAS,CAAC,IAAI,CAAC5G,OAAO,CAAC;IAC5B,IAAI,CAAC4C,KAAK,GAAGA,KAAK;EACtB;EACA;AACJ;AACA;AACA;EACIgE,SAAS,CAAChI,IAAI,EAAE;IACZ,IAAI,CAACiI,IAAI,GAAG,IAAIvI,YAAY,EAAE;IAC9B,IAAI,CAACuI,IAAI,CAAClE,GAAG,CAAC,IAAI,CAAC+C,cAAc,CAC5BvD,SAAS,CAACvD,IAAI,CAAC,CACfgI,SAAS,CAAC,CAAC;MAAE7F,MAAM;MAAEQ,MAAM;MAAEc,WAAW;MAAEC;IAAY,CAAC,KAAK;MAC7D,IAAIvB,MAAM,KAAK,IAAI,CAACF,EAAE,CAAC+E,aAAa,EAAE;QAClC,IAAI,CAACD,kBAAkB,CAACmB,IAAI,CAACzE,WAAW,CAAC;MAC7C,CAAC,MACI,IAAId,MAAM,KAAK,IAAI,CAACV,EAAE,CAAC+E,aAAa,EAAE;QACvC,IAAI,CAACD,kBAAkB,CAACmB,IAAI,CAACxE,WAAW,CAAC;MAC7C;IACJ,CAAC,CAAC,CAAC;IACH,IAAI,CAACuE,IAAI,CAAClE,GAAG,CAAC,IAAI,CAAC+C,cAAc,CAC5BjD,WAAW,CAAC7D,IAAI,CAAC,CACjBgI,SAAS,CAAC,CAAC;MAAE7F,MAAM;MAAEsB;IAAY,CAAC,KAAK;MACxC,IAAItB,MAAM,KAAK,IAAI,CAACF,EAAE,CAAC+E,aAAa,EAAE;QAClC,IAAI,CAACD,kBAAkB,CAACmB,IAAI,CAACzE,WAAW,CAAC;MAC7C;IACJ,CAAC,CAAC,CAAC;EACP;EACA;AACJ;AACA;AACA;EACIiE,QAAQ,CAAClF,SAAS,EAAE;IAChB,IAAI,IAAI,CAACyF,IAAI,EAAE;MACX,IAAI,CAACA,IAAI,CAACE,WAAW,EAAE;IAC3B;IACA;IACA,MAAMnE,KAAK,GAAG,IAAI,CAAC8C,cAAc,CAAC5C,IAAI,CAAC1B,SAAS,CAAC;IACjD,IAAIwB,KAAK,EAAE;MACP;MACA,MAAMoE,YAAY,GAAGpE,KAAK,CAAC/D,KAAK,CAAC4E,UAAU,CAACC,OAAO,CAAC,IAAI,CAAC7C,EAAE,CAAC+E,aAAa,CAAC;MAC1E,IAAIoB,YAAY,KAAK,CAAC,CAAC,EAAE;QACrBpE,KAAK,CAAC/D,KAAK,CAAC4E,UAAU,CAACG,MAAM,CAACoD,YAAY,EAAE,CAAC,CAAC;MAClD;MACA,IAAI,IAAI,CAACR,YAAY,IAAI5D,KAAK,CAAC/D,KAAK,IAAI+D,KAAK,CAAC/D,KAAK,CAAC2E,MAAM,EAAE;QACxD;QACA,IAAIyD,UAAU,GAAGrE,KAAK,CAAC/D,KAAK,CAAC2E,MAAM,CAACE,OAAO,CAAC,IAAI,CAAC8C,YAAY,CAAC;QAC9D,IAAIS,UAAU,KAAK,CAAC,CAAC,EAAE;UACnBrE,KAAK,CAAC/D,KAAK,CAAC2E,MAAM,CAACI,MAAM,CAACqD,UAAU,EAAE,CAAC,CAAC;QAC5C;MACJ;IACJ;EACJ;EACA;AACJ;AACA;EACIC,WAAW,GAAG;IACV,IAAI,CAACZ,QAAQ,CAAC,IAAI,CAACtG,OAAO,CAAC;EAC/B;AACJ;AACAyF,gBAAgB,CAACb,IAAI,GAAG,SAASuC,wBAAwB,CAACrC,CAAC,EAAE;EAAE,OAAO,KAAKA,CAAC,IAAIW,gBAAgB,EAAEhH,MAAM,CAAC2I,iBAAiB,CAAC3I,MAAM,CAACP,UAAU,CAAC,EAAEO,MAAM,CAAC2I,iBAAiB,CAACpG,cAAc,CAAC,CAAC;AAAE,CAAC;AAC3LyE,gBAAgB,CAAC4B,IAAI,GAAG,aAAc5I,MAAM,CAAC6I,iBAAiB,CAAC;EAAEjC,IAAI,EAAEI,gBAAgB;EAAE8B,SAAS,EAAE,CAAC,CAAC,EAAE,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;EAAEC,MAAM,EAAE;IAAExH,OAAO,EAAE,SAAS;IAAEwG,YAAY,EAAE;EAAe,CAAC;EAAEiB,OAAO,EAAE;IAAE9B,kBAAkB,EAAE;EAAqB,CAAC;EAAE+B,QAAQ,EAAE,CAACjJ,MAAM,CAACkJ,oBAAoB;AAAE,CAAC,CAAC;AAC1R;AACAlC,gBAAgB,CAACL,cAAc,GAAG,MAAM,CACpC;EAAEC,IAAI,EAAEnH;AAAW,CAAC,EACpB;EAAEmH,IAAI,EAAErE;AAAe,CAAC,CAC3B;AACDyE,gBAAgB,CAACmC,cAAc,GAAG;EAC9B5H,OAAO,EAAE,CAAC;IAAEqF,IAAI,EAAErH;EAAM,CAAC,CAAC;EAC1BwI,YAAY,EAAE,CAAC;IAAEnB,IAAI,EAAErH;EAAM,CAAC,CAAC;EAC/B2H,kBAAkB,EAAE,CAAC;IAAEN,IAAI,EAAEpH;EAAO,CAAC;AACzC,CAAC;AACD,CAAC,YAAY;EAAE,CAAC,OAAOsH,SAAS,KAAK,WAAW,IAAIA,SAAS,KAAK9G,MAAM,CAAC+G,iBAAiB,CAACC,gBAAgB,EAAE,CAAC;IACtGJ,IAAI,EAAEtH,SAAS;IACf4C,IAAI,EAAE,CAAC;MAAEkH,QAAQ,EAAE;IAAY,CAAC;EACpC,CAAC,CAAC,EAAE,YAAY;IAAE,OAAO,CAAC;MAAExC,IAAI,EAAE5G,MAAM,CAACP;IAAW,CAAC,EAAE;MAAEmH,IAAI,EAAErE;IAAe,CAAC,CAAC;EAAE,CAAC,EAAE;IAAE2E,kBAAkB,EAAE,CAAC;MACpGN,IAAI,EAAEpH;IACV,CAAC,CAAC;IAAE+B,OAAO,EAAE,CAAC;MACVqF,IAAI,EAAErH;IACV,CAAC,CAAC;IAAEwI,YAAY,EAAE,CAAC;MACfnB,IAAI,EAAErH;IACV,CAAC;EAAE,CAAC,CAAC;AAAE,CAAC,GAAG;;AAEnB;AACA;AACA;AACA;AACA,MAAM8J,aAAa,CAAC;EAChB;AACJ;AACA;EACI,OAAOC,OAAO,GAAG;IACb,OAAO;MACHC,QAAQ,EAAEF,aAAa;MACvBG,SAAS,EAAE,CAACjH,cAAc;IAC9B,CAAC;EACL;AACJ;AACA8G,aAAa,CAAClD,IAAI,GAAG,SAASsD,qBAAqB,CAACpD,CAAC,EAAE;EAAE,OAAO,KAAKA,CAAC,IAAIgD,aAAa,GAAG;AAAE,CAAC;AAC7FA,aAAa,CAACK,IAAI,GAAG,aAAc1J,MAAM,CAAC2J,gBAAgB,CAAC;EAAE/C,IAAI,EAAEyC;AAAc,CAAC,CAAC;AACnFA,aAAa,CAACO,IAAI,GAAG,aAAc5J,MAAM,CAAC6J,gBAAgB,CAAC,CAAC,CAAC,CAAC;AAC9D,CAAC,YAAY;EAAE,CAAC,OAAO/C,SAAS,KAAK,WAAW,IAAIA,SAAS,KAAK9G,MAAM,CAAC+G,iBAAiB,CAACsC,aAAa,EAAE,CAAC;IACnGzC,IAAI,EAAEjH,QAAQ;IACduC,IAAI,EAAE,CAAC;MACC4H,OAAO,EAAE,CAAC9C,gBAAgB,CAAC;MAC3B+C,YAAY,EAAE,CAAC/C,gBAAgB;IACnC,CAAC;EACT,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;AAAE,CAAC,GAAG;AACzB,CAAC,YAAY;EAAE,CAAC,OAAOgD,SAAS,KAAK,WAAW,IAAIA,SAAS,KAAKhK,MAAM,CAACiK,kBAAkB,CAACZ,aAAa,EAAE;IAAEU,YAAY,EAAE,CAAC/C,gBAAgB,CAAC;IAAE8C,OAAO,EAAE,CAAC9C,gBAAgB;EAAE,CAAC,CAAC;AAAE,CAAC,GAAG;;AAEnL;AACA;AACA;AACA;AACA;AACA,MAAMkD,gBAAgB,GAAG,IAAI1I,YAAY,CAAC,CAACwD,UAAU,EAAE3E,OAAO,KAAK;EAC/D,OAAO,IAAI8J,SAAS,CAACnF,UAAU,EAAE3E,OAAO,CAAC;AAC7C,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM8J,SAAS,CAAC;EACZ;AACJ;AACA;AACA;AACA;AACA;EACIjK,WAAW,CAAC8E,UAAU,GAAG,EAAE,EAAE3E,OAAO,GAAG,CAAC,CAAC,EAAE0E,MAAM,EAAE;IAC/C,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC3E,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC0E,MAAM,GAAGA,MAAM;IACpB;IACA,IAAI,CAACqF,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,QAAQ,GAAG,IAAIzK,OAAO,EAAE;IAC7B,IAAI,CAACwI,IAAI,GAAG,IAAIvI,YAAY,EAAE;EAClC;EACA;AACJ;AACA;AACA;EACIyK,KAAK,CAAC3G,IAAI,EAAE;IACR,IAAI,CAACyG,QAAQ,GAAG,IAAI;EACxB;EACA;AACJ;AACA;EACIG,GAAG,GAAG;IACF,IAAI,CAACH,QAAQ,GAAG,KAAK;EACzB;EACA;AACJ;AACA;AACA;EACInH,MAAM,CAACuH,MAAM,EAAE;IACX,IAAI,CAACJ,QAAQ,GAAG,KAAK;EACzB;EACA;AACJ;AACA;EACIlH,MAAM,GAAG;IACL,IAAI,CAACkH,QAAQ,GAAG,KAAK;EACzB;EACA;AACJ;AACA;AACA;AACA;EACItF,EAAE,CAAC9C,KAAK,EAAEyI,QAAQ,EAAE;IAChB,IAAI,CAACrC,IAAI,CAAClE,GAAG,CAAC,IAAI,CAACmG,QAAQ,CACtBtI,IAAI,CAACjC,MAAM,CAAC,CAAC;MAAE6B;IAAU,CAAC,KAAKA,SAAS,KAAKK,KAAK,CAAC,CAAC,CACpDmG,SAAS,CAAC,CAAC;MAAEjG;IAAK,CAAC,KAAK;MACzBuI,QAAQ,CAAC,GAAGvI,IAAI,CAAC;IACrB,CAAC,CAAC,CAAC;EACP;EACA;AACJ;AACA;EACIuC,OAAO,GAAG;IACN,IAAI,CAAC2D,IAAI,CAACE,WAAW,EAAE;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACID,IAAI,CAAC1G,SAAS,EAAE,GAAGO,IAAI,EAAE;IACrB,IAAI,CAACmI,QAAQ,CAACjF,IAAI,CAAC;MAAEzD,SAAS;MAAEO;IAAK,CAAC,CAAC;EAC3C;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS8E,gBAAgB,EAAEzE,cAAc,EAAE8G,aAAa,EAAE9H,OAAO,EAAEC,YAAY,EAAEvB,KAAK,EAAEM,UAAU,EAAE4J,SAAS,EAAED,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}