{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\nclass LeafletUtil {\n  static mapToArray(map) {\n    const toReturn = [];\n    for (const k in map) {\n      if (map.hasOwnProperty(k)) {\n        toReturn.push(map[k]);\n      }\n    }\n    return toReturn;\n  }\n  static handleEvent(zone, eventEmitter, event) {\n    // Don't want to emit if there are no observers\n    if (0 < eventEmitter.observers.length) {\n      zone.run(() => {\n        eventEmitter.emit(event);\n      });\n    }\n  }\n}\nclass LeafletDirective {\n  constructor(element, zone) {\n    this.element = element;\n    this.zone = zone;\n    this.DEFAULT_ZOOM = 1;\n    this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n    this.DEFAULT_FPZ_OPTIONS = {};\n    this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS;\n    // Default configuration\n    this.options = {};\n    // Configure callback function for the map\n    this.mapReady = new EventEmitter();\n    this.zoomChange = new EventEmitter();\n    this.centerChange = new EventEmitter();\n    // Mouse Map Events\n    this.onClick = new EventEmitter();\n    this.onDoubleClick = new EventEmitter();\n    this.onMouseDown = new EventEmitter();\n    this.onMouseUp = new EventEmitter();\n    this.onMouseMove = new EventEmitter();\n    this.onMouseOver = new EventEmitter();\n    this.onMouseOut = new EventEmitter();\n    // Map Move Events\n    this.onMapMove = new EventEmitter();\n    this.onMapMoveStart = new EventEmitter();\n    this.onMapMoveEnd = new EventEmitter();\n    // Map Zoom Events\n    this.onMapZoom = new EventEmitter();\n    this.onMapZoomStart = new EventEmitter();\n    this.onMapZoomEnd = new EventEmitter();\n    // Nothing here\n  }\n\n  ngOnInit() {\n    // Create the map outside of angular so the various map events don't trigger change detection\n    this.zone.runOutsideAngular(() => {\n      // Create the map with some reasonable defaults\n      this.map = map(this.element.nativeElement, this.options);\n      this.addMapEventListeners();\n    });\n    // Only setView if there is a center/zoom\n    if (null != this.center && null != this.zoom) {\n      this.setView(this.center, this.zoom);\n    }\n    // Set up all the initial settings\n    if (null != this.fitBounds) {\n      this.setFitBounds(this.fitBounds);\n    }\n    if (null != this.maxBounds) {\n      this.setMaxBounds(this.maxBounds);\n    }\n    if (null != this.minZoom) {\n      this.setMinZoom(this.minZoom);\n    }\n    if (null != this.maxZoom) {\n      this.setMaxZoom(this.maxZoom);\n    }\n    this.doResize();\n    // Fire map ready event\n    this.mapReady.emit(this.map);\n  }\n  ngOnChanges(changes) {\n    /*\n     * The following code is to address an issue with our (basic) implementation of\n     * zooming and panning. From our testing, it seems that a pan operation followed\n     * by a zoom operation in the same thread will interfere with eachother. The zoom\n     * operation interrupts/cancels the pan, resulting in a final center point that is\n     * inaccurate. The solution seems to be to either separate them with a timeout or\n      * to collapse them into a setView call.\n     */\n    // Zooming and Panning\n    if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n      this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n    }\n    // Set the zoom level\n    else if (changes['zoom']) {\n      this.setZoom(changes['zoom'].currentValue);\n    }\n    // Set the map center\n    else if (changes['center']) {\n      this.setCenter(changes['center'].currentValue);\n    }\n    // Other options\n    if (changes['fitBounds']) {\n      this.setFitBounds(changes['fitBounds'].currentValue);\n    }\n    if (changes['maxBounds']) {\n      this.setMaxBounds(changes['maxBounds'].currentValue);\n    }\n    if (changes['minZoom']) {\n      this.setMinZoom(changes['minZoom'].currentValue);\n    }\n    if (changes['maxZoom']) {\n      this.setMaxZoom(changes['maxZoom'].currentValue);\n    }\n  }\n  ngOnDestroy() {\n    // If this directive is destroyed, the map is too\n    if (null != this.map) {\n      this.map.remove();\n    }\n  }\n  getMap() {\n    return this.map;\n  }\n  onResize() {\n    this.delayResize();\n  }\n  addMapEventListeners() {\n    const registerEventHandler = (eventName, handler) => {\n      this.map.on(eventName, handler);\n    };\n    // Add all the pass-through mouse event handlers\n    registerEventHandler('click', e => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n    registerEventHandler('dblclick', e => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n    registerEventHandler('mousedown', e => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n    registerEventHandler('mouseup', e => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n    registerEventHandler('mouseover', e => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n    registerEventHandler('mouseout', e => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n    registerEventHandler('mousemove', e => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n    registerEventHandler('zoomstart', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n    registerEventHandler('zoom', e => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n    registerEventHandler('zoomend', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n    registerEventHandler('movestart', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n    registerEventHandler('move', e => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n    registerEventHandler('moveend', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e));\n    // Update any things for which we provide output bindings\n    const outputUpdateHandler = () => {\n      const zoom = this.map.getZoom();\n      if (zoom !== this.zoom) {\n        this.zoom = zoom;\n        LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n      }\n      const center = this.map.getCenter();\n      if (null != center || null != this.center) {\n        if ((null == center || null == this.center) && center !== this.center || center.lat !== this.center.lat || center.lng !== this.center.lng) {\n          this.center = center;\n          LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n        }\n      }\n    };\n    registerEventHandler('moveend', outputUpdateHandler);\n    registerEventHandler('zoomend', outputUpdateHandler);\n  }\n  /**\n   * Resize the map to fit it's parent container\n   */\n  doResize() {\n    // Run this outside of angular so the map events stay outside of angular\n    this.zone.runOutsideAngular(() => {\n      // Invalidate the map size to trigger it to update itself\n      if (null != this.map) {\n        this.map.invalidateSize({});\n      }\n    });\n  }\n  /**\n   * Manage a delayed resize of the component\n   */\n  delayResize() {\n    if (null != this.resizeTimer) {\n      clearTimeout(this.resizeTimer);\n    }\n    this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n  }\n  /**\n   * Set the view (center/zoom) all at once\n   * @param center The new center\n   * @param zoom The new zoom level\n   */\n  setView(center, zoom) {\n    if (null != this.map && null != center && null != zoom) {\n      this.map.setView(center, zoom, this.zoomPanOptions);\n    }\n  }\n  /**\n   * Set the map zoom level\n   * @param zoom the new zoom level for the map\n   */\n  setZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setZoom(zoom, this.zoomOptions);\n    }\n  }\n  /**\n   * Set the center of the map\n   * @param center the center point\n   */\n  setCenter(center) {\n    if (null != this.map && null != center) {\n      this.map.panTo(center, this.panOptions);\n    }\n  }\n  /**\n   * Fit the map to the bounds\n   * @param latLngBounds the boundary to set\n   */\n  setFitBounds(latLngBounds) {\n    if (null != this.map && null != latLngBounds) {\n      this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n    }\n  }\n  /**\n   * Set the map's max bounds\n   * @param latLngBounds the boundary to set\n   */\n  setMaxBounds(latLngBounds) {\n    if (null != this.map && null != latLngBounds) {\n      this.map.setMaxBounds(latLngBounds);\n    }\n  }\n  /**\n   * Set the map's min zoom\n   * @param number the new min zoom\n   */\n  setMinZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setMinZoom(zoom);\n    }\n  }\n  /**\n   * Set the map's min zoom\n   * @param number the new min zoom\n   */\n  setMaxZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setMaxZoom(zoom);\n    }\n  }\n}\nLeafletDirective.ɵfac = function LeafletDirective_Factory(t) {\n  return new (t || LeafletDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\nLeafletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletDirective,\n  selectors: [[\"\", \"leaflet\", \"\"]],\n  hostBindings: function LeafletDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"resize\", function LeafletDirective_resize_HostBindingHandler() {\n        return ctx.onResize();\n      }, false, i0.ɵɵresolveWindow);\n    }\n  },\n  inputs: {\n    fitBoundsOptions: [\"leafletFitBoundsOptions\", \"fitBoundsOptions\"],\n    panOptions: [\"leafletPanOptions\", \"panOptions\"],\n    zoomOptions: [\"leafletZoomOptions\", \"zoomOptions\"],\n    zoomPanOptions: [\"leafletZoomPanOptions\", \"zoomPanOptions\"],\n    options: [\"leafletOptions\", \"options\"],\n    zoom: [\"leafletZoom\", \"zoom\"],\n    center: [\"leafletCenter\", \"center\"],\n    fitBounds: [\"leafletFitBounds\", \"fitBounds\"],\n    maxBounds: [\"leafletMaxBounds\", \"maxBounds\"],\n    minZoom: [\"leafletMinZoom\", \"minZoom\"],\n    maxZoom: [\"leafletMaxZoom\", \"maxZoom\"]\n  },\n  outputs: {\n    mapReady: \"leafletMapReady\",\n    zoomChange: \"leafletZoomChange\",\n    centerChange: \"leafletCenterChange\",\n    onClick: \"leafletClick\",\n    onDoubleClick: \"leafletDoubleClick\",\n    onMouseDown: \"leafletMouseDown\",\n    onMouseUp: \"leafletMouseUp\",\n    onMouseMove: \"leafletMouseMove\",\n    onMouseOver: \"leafletMouseOver\",\n    onMouseOut: \"leafletMouseOut\",\n    onMapMove: \"leafletMapMove\",\n    onMapMoveStart: \"leafletMapMoveStart\",\n    onMapMoveEnd: \"leafletMapMoveEnd\",\n    onMapZoom: \"leafletMapZoom\",\n    onMapZoomStart: \"leafletMapZoomStart\",\n    onMapZoomEnd: \"leafletMapZoomEnd\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leaflet]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    fitBoundsOptions: [{\n      type: Input,\n      args: ['leafletFitBoundsOptions']\n    }],\n    panOptions: [{\n      type: Input,\n      args: ['leafletPanOptions']\n    }],\n    zoomOptions: [{\n      type: Input,\n      args: ['leafletZoomOptions']\n    }],\n    zoomPanOptions: [{\n      type: Input,\n      args: ['leafletZoomPanOptions']\n    }],\n    options: [{\n      type: Input,\n      args: ['leafletOptions']\n    }],\n    mapReady: [{\n      type: Output,\n      args: ['leafletMapReady']\n    }],\n    zoom: [{\n      type: Input,\n      args: ['leafletZoom']\n    }],\n    zoomChange: [{\n      type: Output,\n      args: ['leafletZoomChange']\n    }],\n    center: [{\n      type: Input,\n      args: ['leafletCenter']\n    }],\n    centerChange: [{\n      type: Output,\n      args: ['leafletCenterChange']\n    }],\n    fitBounds: [{\n      type: Input,\n      args: ['leafletFitBounds']\n    }],\n    maxBounds: [{\n      type: Input,\n      args: ['leafletMaxBounds']\n    }],\n    minZoom: [{\n      type: Input,\n      args: ['leafletMinZoom']\n    }],\n    maxZoom: [{\n      type: Input,\n      args: ['leafletMaxZoom']\n    }],\n    onClick: [{\n      type: Output,\n      args: ['leafletClick']\n    }],\n    onDoubleClick: [{\n      type: Output,\n      args: ['leafletDoubleClick']\n    }],\n    onMouseDown: [{\n      type: Output,\n      args: ['leafletMouseDown']\n    }],\n    onMouseUp: [{\n      type: Output,\n      args: ['leafletMouseUp']\n    }],\n    onMouseMove: [{\n      type: Output,\n      args: ['leafletMouseMove']\n    }],\n    onMouseOver: [{\n      type: Output,\n      args: ['leafletMouseOver']\n    }],\n    onMouseOut: [{\n      type: Output,\n      args: ['leafletMouseOut']\n    }],\n    onMapMove: [{\n      type: Output,\n      args: ['leafletMapMove']\n    }],\n    onMapMoveStart: [{\n      type: Output,\n      args: ['leafletMapMoveStart']\n    }],\n    onMapMoveEnd: [{\n      type: Output,\n      args: ['leafletMapMoveEnd']\n    }],\n    onMapZoom: [{\n      type: Output,\n      args: ['leafletMapZoom']\n    }],\n    onMapZoomStart: [{\n      type: Output,\n      args: ['leafletMapZoomStart']\n    }],\n    onMapZoomEnd: [{\n      type: Output,\n      args: ['leafletMapZoomEnd']\n    }],\n    onResize: [{\n      type: HostListener,\n      args: ['window:resize', []]\n    }]\n  });\n})();\nclass LeafletDirectiveWrapper {\n  constructor(leafletDirective) {\n    this.leafletDirective = leafletDirective;\n  }\n  init() {\n    // Nothing for now\n  }\n  getMap() {\n    return this.leafletDirective.getMap();\n  }\n}\n\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\nclass LeafletLayerDirective {\n  constructor(leafletDirective, zone) {\n    this.zone = zone;\n    // Layer Events\n    this.onAdd = new EventEmitter();\n    this.onRemove = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n  }\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n  }\n  ngOnDestroy() {\n    if (null != this.layer) {\n      // Unregister the event handlers\n      this.removeLayerEventListeners(this.layer);\n      // Remove the layer from the map\n      this.layer.remove();\n    }\n  }\n  ngOnChanges(changes) {\n    if (changes['layer']) {\n      // Update the layer\n      const p = changes['layer'].previousValue;\n      const n = changes['layer'].currentValue;\n      this.zone.runOutsideAngular(() => {\n        if (null != p) {\n          this.removeLayerEventListeners(p);\n          p.remove();\n        }\n        if (null != n) {\n          this.addLayerEventListeners(n);\n          this.leafletDirective.getMap().addLayer(n);\n        }\n      });\n    }\n  }\n  addLayerEventListeners(l) {\n    this.onAddLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n    l.on('add', this.onAddLayerHandler);\n    this.onRemoveLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n    l.on('remove', this.onRemoveLayerHandler);\n  }\n  removeLayerEventListeners(l) {\n    l.off('add', this.onAddLayerHandler);\n    l.off('remove', this.onRemoveLayerHandler);\n  }\n}\nLeafletLayerDirective.ɵfac = function LeafletLayerDirective_Factory(t) {\n  return new (t || LeafletLayerDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.NgZone));\n};\nLeafletLayerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayerDirective,\n  selectors: [[\"\", \"leafletLayer\", \"\"]],\n  inputs: {\n    layer: [\"leafletLayer\", \"layer\"]\n  },\n  outputs: {\n    onAdd: \"leafletLayerAdd\",\n    onRemove: \"leafletLayerRemove\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayer]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layer: [{\n      type: Input,\n      args: ['leafletLayer']\n    }],\n    onAdd: [{\n      type: Output,\n      args: ['leafletLayerAdd']\n    }],\n    onRemove: [{\n      type: Output,\n      args: ['leafletLayerRemove']\n    }]\n  });\n})();\n\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nclass LeafletLayersDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.layersDiffer = this.differs.find([]).create();\n  }\n  // Set/get the layers\n  set layers(v) {\n    this.layersValue = v;\n    // Now that we have a differ, do an immediate layer update\n    this.updateLayers();\n  }\n  get layers() {\n    return this.layersValue;\n  }\n  ngDoCheck() {\n    this.updateLayers();\n  }\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n    // Update layers once the map is ready\n    this.updateLayers();\n  }\n  ngOnDestroy() {\n    this.layers = [];\n  }\n  /**\n   * Update the state of the layers.\n   * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n   * This is important because it allows us to react to changes to the contents of the array as well\n   * as changes to the actual array instance.\n   */\n  updateLayers() {\n    const map = this.leafletDirective.getMap();\n    if (null != map && null != this.layersDiffer) {\n      const changes = this.layersDiffer.diff(this.layersValue);\n      if (null != changes) {\n        // Run outside angular to ensure layer events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n          changes.forEachRemovedItem(c => {\n            map.removeLayer(c.item);\n          });\n          changes.forEachAddedItem(c => {\n            map.addLayer(c.item);\n          });\n        });\n      }\n    }\n  }\n}\nLeafletLayersDirective.ɵfac = function LeafletLayersDirective_Factory(t) {\n  return new (t || LeafletLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\nLeafletLayersDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayersDirective,\n  selectors: [[\"\", \"leafletLayers\", \"\"]],\n  inputs: {\n    layers: [\"leafletLayers\", \"layers\"]\n  }\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayersDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayers]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.IterableDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layers: [{\n      type: Input,\n      args: ['leafletLayers']\n    }]\n  });\n})();\nclass LeafletControlLayersChanges {\n  constructor() {\n    this.layersRemoved = 0;\n    this.layersChanged = 0;\n    this.layersAdded = 0;\n  }\n  changed() {\n    return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n  }\n}\nclass LeafletControlLayersWrapper {\n  constructor(zone, layersControlReady) {\n    this.zone = zone;\n    this.layersControlReady = layersControlReady;\n  }\n  getLayersControl() {\n    return this.layersControl;\n  }\n  init(controlConfig, controlOptions) {\n    const baseLayers = controlConfig.baseLayers || {};\n    const overlays = controlConfig.overlays || {};\n    // Create the control outside of angular to ensure events don't trigger change detection\n    this.zone.runOutsideAngular(() => {\n      this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n    });\n    this.layersControlReady.emit(this.layersControl);\n    return this.layersControl;\n  }\n  applyBaseLayerChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n    }\n    return results;\n  }\n  applyOverlayChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addOverlay);\n    }\n    return results;\n  }\n  applyChanges(changes, addFn) {\n    const results = new LeafletControlLayersChanges();\n    if (null != changes) {\n      // All layer management is outside angular to avoid layer events from triggering change detection\n      this.zone.runOutsideAngular(() => {\n        changes.forEachChangedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersChanged++;\n        });\n        changes.forEachRemovedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          results.layersRemoved++;\n        });\n        changes.forEachAddedItem(c => {\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersAdded++;\n        });\n      });\n    }\n    return results;\n  }\n}\nclass LeafletControlLayersConfig {\n  constructor() {\n    this.baseLayers = {};\n    this.overlays = {};\n  }\n}\n\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\nclass LeafletLayersControlDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n    // Generate differs\n    this.baseLayersDiffer = this.differs.find({}).create();\n    this.overlaysDiffer = this.differs.find({}).create();\n  }\n  set layersControlConfig(v) {\n    // Validation/init stuff\n    if (null == v) {\n      v = new LeafletControlLayersConfig();\n    }\n    if (null == v.baseLayers) {\n      v.baseLayers = {};\n    }\n    if (null == v.overlays) {\n      v.overlays = {};\n    }\n    // Store the value\n    this.layersControlConfigValue = v;\n    // Update the map\n    this.updateLayers();\n  }\n  get layersControlConfig() {\n    return this.layersControlConfigValue;\n  }\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n    // Set up control outside of angular to avoid change detection when using the control\n    this.zone.runOutsideAngular(() => {\n      // Set up all the initial settings\n      this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n    });\n    this.updateLayers();\n  }\n  ngOnDestroy() {\n    this.layersControlConfig = {\n      baseLayers: {},\n      overlays: {}\n    };\n    this.controlLayers.getLayersControl().remove();\n  }\n  ngDoCheck() {\n    this.updateLayers();\n  }\n  updateLayers() {\n    const map = this.leafletDirective.getMap();\n    const layersControl = this.controlLayers.getLayersControl();\n    if (null != map && null != layersControl) {\n      // Run the baselayers differ\n      if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n        const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n        this.controlLayers.applyBaseLayerChanges(changes);\n      }\n      // Run the overlays differ\n      if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n        const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n        this.controlLayers.applyOverlayChanges(changes);\n      }\n    }\n  }\n}\nLeafletLayersControlDirective.ɵfac = function LeafletLayersControlDirective_Factory(t) {\n  return new (t || LeafletLayersControlDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\nLeafletLayersControlDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayersControlDirective,\n  selectors: [[\"\", \"leafletLayersControl\", \"\"]],\n  inputs: {\n    layersControlConfig: [\"leafletLayersControl\", \"layersControlConfig\"],\n    layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"]\n  },\n  outputs: {\n    layersControlReady: \"leafletLayersControlReady\"\n  }\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayersControlDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayersControl]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.KeyValueDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layersControlConfig: [{\n      type: Input,\n      args: ['leafletLayersControl']\n    }],\n    layersControlOptions: [{\n      type: Input,\n      args: ['leafletLayersControlOptions']\n    }],\n    layersControlReady: [{\n      type: Output,\n      args: ['leafletLayersControlReady']\n    }]\n  });\n})();\n\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\nclass LeafletBaseLayersDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    // Output for once the layers control is ready\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n    this.baseLayersDiffer = this.differs.find({}).create();\n  }\n  // Set/get baseLayers\n  set baseLayers(v) {\n    this.baseLayersValue = v;\n    this.updateBaseLayers();\n  }\n  get baseLayers() {\n    return this.baseLayersValue;\n  }\n  ngOnDestroy() {\n    this.baseLayers = {};\n    if (null != this.controlLayers.getLayersControl()) {\n      this.controlLayers.getLayersControl().remove();\n    }\n  }\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n    // Create the control outside angular to prevent events from triggering chnage detection\n    this.zone.runOutsideAngular(() => {\n      // Initially configure the controlLayers\n      this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n    });\n    this.updateBaseLayers();\n  }\n  ngDoCheck() {\n    this.updateBaseLayers();\n  }\n  updateBaseLayers() {\n    const map = this.leafletDirective.getMap();\n    const layersControl = this.controlLayers.getLayersControl();\n    if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n      const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n      const results = this.controlLayers.applyBaseLayerChanges(changes);\n      if (results.changed()) {\n        this.syncBaseLayer();\n      }\n    }\n  }\n  /**\n   * Check the current base layer and change it to the new one if necessary\n   */\n  syncBaseLayer() {\n    const map = this.leafletDirective.getMap();\n    const layers = LeafletUtil.mapToArray(this.baseLayers);\n    let foundLayer;\n    // Search all the layers in the map to see if we can find them in the baselayer array\n    map.eachLayer(l => {\n      foundLayer = layers.find(bl => l === bl);\n    });\n    // Did we find the layer?\n    if (null != foundLayer) {\n      // Yes - set the baselayer to the one we found\n      this.baseLayer = foundLayer;\n    } else {\n      // No - set the baselayer to the first in the array and add it to the map\n      if (layers.length > 0) {\n        this.baseLayer = layers[0];\n        // Add layers outside of angular to prevent events from triggering change detection\n        this.zone.runOutsideAngular(() => {\n          this.baseLayer.addTo(map);\n        });\n      }\n    }\n  }\n}\nLeafletBaseLayersDirective.ɵfac = function LeafletBaseLayersDirective_Factory(t) {\n  return new (t || LeafletBaseLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\nLeafletBaseLayersDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletBaseLayersDirective,\n  selectors: [[\"\", \"leafletBaseLayers\", \"\"]],\n  inputs: {\n    baseLayers: [\"leafletBaseLayers\", \"baseLayers\"],\n    layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"]\n  },\n  outputs: {\n    layersControlReady: \"leafletLayersControlReady\"\n  }\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletBaseLayersDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletBaseLayers]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.KeyValueDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    baseLayers: [{\n      type: Input,\n      args: ['leafletBaseLayers']\n    }],\n    layersControlOptions: [{\n      type: Input,\n      args: ['leafletLayersControlOptions']\n    }],\n    layersControlReady: [{\n      type: Output,\n      args: ['leafletLayersControlReady']\n    }]\n  });\n})();\nclass LeafletModule {}\nLeafletModule.ɵfac = function LeafletModule_Factory(t) {\n  return new (t || LeafletModule)();\n};\nLeafletModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LeafletModule\n});\nLeafletModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletModule, [{\n    type: NgModule,\n    args: [{\n      exports: [LeafletDirective, LeafletLayerDirective, LeafletLayersDirective, LeafletLayersControlDirective, LeafletBaseLayersDirective],\n      declarations: [LeafletDirective, LeafletLayerDirective, LeafletLayersDirective, LeafletLayersControlDirective, LeafletBaseLayersDirective]\n    }]\n  }], null, null);\n})();\nclass LeafletTileLayerDefinition {\n  constructor(type, url, options) {\n    this.type = type;\n    this.url = url;\n    this.options = options;\n  }\n  /**\n   * Creates a TileLayer from the provided definition. This is a convenience function\n   * to help with generating layers from objects.\n   *\n   * @param layerDef The layer to create\n   * @returns {TileLayer} The TileLayer that has been created\n   */\n  static createTileLayer(layerDef) {\n    let layer;\n    switch (layerDef.type) {\n      case 'xyz':\n        layer = tileLayer(layerDef.url, layerDef.options);\n        break;\n      case 'wms':\n      default:\n        layer = tileLayer.wms(layerDef.url, layerDef.options);\n        break;\n    }\n    return layer;\n  }\n  /**\n   * Creates a TileLayer for each key in the incoming map. This is a convenience function\n   * for generating an associative array of layers from an associative array of objects\n   *\n   * @param layerDefs A map of key to tile layer definition\n   * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n   */\n  static createTileLayers(layerDefs) {\n    const layers = {};\n    for (const k in layerDefs) {\n      if (layerDefs.hasOwnProperty(k)) {\n        layers[k] = LeafletTileLayerDefinition.createTileLayer(layerDefs[k]);\n      }\n    }\n    return layers;\n  }\n  /**\n   * Create a Tile Layer from the current state of this object\n   *\n   * @returns {TileLayer} A new TileLayer\n   */\n  createTileLayer() {\n    return LeafletTileLayerDefinition.createTileLayer(this);\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil };\n//# sourceMappingURL=asymmetrik-ngx-leaflet.mjs.map","map":{"version":3,"names":["i0","EventEmitter","Directive","Input","Output","HostListener","NgModule","latLng","map","control","tileLayer","LeafletUtil","mapToArray","toReturn","k","hasOwnProperty","push","handleEvent","zone","eventEmitter","event","observers","length","run","emit","LeafletDirective","constructor","element","DEFAULT_ZOOM","DEFAULT_CENTER","DEFAULT_FPZ_OPTIONS","fitBoundsOptions","panOptions","zoomOptions","zoomPanOptions","options","mapReady","zoomChange","centerChange","onClick","onDoubleClick","onMouseDown","onMouseUp","onMouseMove","onMouseOver","onMouseOut","onMapMove","onMapMoveStart","onMapMoveEnd","onMapZoom","onMapZoomStart","onMapZoomEnd","ngOnInit","runOutsideAngular","nativeElement","addMapEventListeners","center","zoom","setView","fitBounds","setFitBounds","maxBounds","setMaxBounds","minZoom","setMinZoom","maxZoom","setMaxZoom","doResize","ngOnChanges","changes","currentValue","setZoom","setCenter","ngOnDestroy","remove","getMap","onResize","delayResize","registerEventHandler","eventName","handler","on","e","outputUpdateHandler","getZoom","getCenter","lat","lng","invalidateSize","resizeTimer","clearTimeout","setTimeout","bind","panTo","latLngBounds","ɵfac","ElementRef","NgZone","ɵdir","type","args","selector","LeafletDirectiveWrapper","leafletDirective","init","LeafletLayerDirective","onAdd","onRemove","layer","removeLayerEventListeners","p","previousValue","n","addLayerEventListeners","addLayer","l","onAddLayerHandler","onRemoveLayerHandler","off","LeafletLayersDirective","differs","layersDiffer","find","create","layers","v","layersValue","updateLayers","ngDoCheck","diff","forEachRemovedItem","c","removeLayer","item","forEachAddedItem","IterableDiffers","LeafletControlLayersChanges","layersRemoved","layersChanged","layersAdded","changed","LeafletControlLayersWrapper","layersControlReady","getLayersControl","layersControl","controlConfig","controlOptions","baseLayers","overlays","applyBaseLayerChanges","results","applyChanges","addBaseLayer","applyOverlayChanges","addOverlay","addFn","forEachChangedItem","call","key","LeafletControlLayersConfig","LeafletLayersControlDirective","controlLayers","baseLayersDiffer","overlaysDiffer","layersControlConfig","layersControlConfigValue","layersControlOptions","addTo","KeyValueDiffers","LeafletBaseLayersDirective","baseLayersValue","updateBaseLayers","syncBaseLayer","foundLayer","eachLayer","bl","baseLayer","LeafletModule","ɵmod","ɵinj","exports","declarations","LeafletTileLayerDefinition","url","createTileLayer","layerDef","wms","createTileLayers","layerDefs"],"sources":["F:/Plantillas/template/node_modules/@asymmetrik/ngx-leaflet/fesm2020/asymmetrik-ngx-leaflet.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\n\nclass LeafletUtil {\n    static mapToArray(map) {\n        const toReturn = [];\n        for (const k in map) {\n            if (map.hasOwnProperty(k)) {\n                toReturn.push(map[k]);\n            }\n        }\n        return toReturn;\n    }\n    static handleEvent(zone, eventEmitter, event) {\n        // Don't want to emit if there are no observers\n        if (0 < eventEmitter.observers.length) {\n            zone.run(() => {\n                eventEmitter.emit(event);\n            });\n        }\n    }\n}\n\nclass LeafletDirective {\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.DEFAULT_ZOOM = 1;\n        this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n        this.DEFAULT_FPZ_OPTIONS = {};\n        this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS;\n        // Default configuration\n        this.options = {};\n        // Configure callback function for the map\n        this.mapReady = new EventEmitter();\n        this.zoomChange = new EventEmitter();\n        this.centerChange = new EventEmitter();\n        // Mouse Map Events\n        this.onClick = new EventEmitter();\n        this.onDoubleClick = new EventEmitter();\n        this.onMouseDown = new EventEmitter();\n        this.onMouseUp = new EventEmitter();\n        this.onMouseMove = new EventEmitter();\n        this.onMouseOver = new EventEmitter();\n        this.onMouseOut = new EventEmitter();\n        // Map Move Events\n        this.onMapMove = new EventEmitter();\n        this.onMapMoveStart = new EventEmitter();\n        this.onMapMoveEnd = new EventEmitter();\n        // Map Zoom Events\n        this.onMapZoom = new EventEmitter();\n        this.onMapZoomStart = new EventEmitter();\n        this.onMapZoomEnd = new EventEmitter();\n        // Nothing here\n    }\n    ngOnInit() {\n        // Create the map outside of angular so the various map events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n            // Create the map with some reasonable defaults\n            this.map = map(this.element.nativeElement, this.options);\n            this.addMapEventListeners();\n        });\n        // Only setView if there is a center/zoom\n        if (null != this.center && null != this.zoom) {\n            this.setView(this.center, this.zoom);\n        }\n        // Set up all the initial settings\n        if (null != this.fitBounds) {\n            this.setFitBounds(this.fitBounds);\n        }\n        if (null != this.maxBounds) {\n            this.setMaxBounds(this.maxBounds);\n        }\n        if (null != this.minZoom) {\n            this.setMinZoom(this.minZoom);\n        }\n        if (null != this.maxZoom) {\n            this.setMaxZoom(this.maxZoom);\n        }\n        this.doResize();\n        // Fire map ready event\n        this.mapReady.emit(this.map);\n    }\n    ngOnChanges(changes) {\n        /*\n         * The following code is to address an issue with our (basic) implementation of\n         * zooming and panning. From our testing, it seems that a pan operation followed\n         * by a zoom operation in the same thread will interfere with eachother. The zoom\n         * operation interrupts/cancels the pan, resulting in a final center point that is\n         * inaccurate. The solution seems to be to either separate them with a timeout or\n          * to collapse them into a setView call.\n         */\n        // Zooming and Panning\n        if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n            this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n        }\n        // Set the zoom level\n        else if (changes['zoom']) {\n            this.setZoom(changes['zoom'].currentValue);\n        }\n        // Set the map center\n        else if (changes['center']) {\n            this.setCenter(changes['center'].currentValue);\n        }\n        // Other options\n        if (changes['fitBounds']) {\n            this.setFitBounds(changes['fitBounds'].currentValue);\n        }\n        if (changes['maxBounds']) {\n            this.setMaxBounds(changes['maxBounds'].currentValue);\n        }\n        if (changes['minZoom']) {\n            this.setMinZoom(changes['minZoom'].currentValue);\n        }\n        if (changes['maxZoom']) {\n            this.setMaxZoom(changes['maxZoom'].currentValue);\n        }\n    }\n    ngOnDestroy() {\n        // If this directive is destroyed, the map is too\n        if (null != this.map) {\n            this.map.remove();\n        }\n    }\n    getMap() {\n        return this.map;\n    }\n    onResize() {\n        this.delayResize();\n    }\n    addMapEventListeners() {\n        const registerEventHandler = (eventName, handler) => {\n            this.map.on(eventName, handler);\n        };\n        // Add all the pass-through mouse event handlers\n        registerEventHandler('click', (e) => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n        registerEventHandler('dblclick', (e) => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n        registerEventHandler('mousedown', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n        registerEventHandler('mouseup', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n        registerEventHandler('mouseover', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n        registerEventHandler('mouseout', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n        registerEventHandler('mousemove', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n        registerEventHandler('zoomstart', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n        registerEventHandler('zoom', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n        registerEventHandler('zoomend', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n        registerEventHandler('movestart', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n        registerEventHandler('move', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n        registerEventHandler('moveend', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e));\n        // Update any things for which we provide output bindings\n        const outputUpdateHandler = () => {\n            const zoom = this.map.getZoom();\n            if (zoom !== this.zoom) {\n                this.zoom = zoom;\n                LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n            }\n            const center = this.map.getCenter();\n            if (null != center || null != this.center) {\n                if (((null == center || null == this.center) && center !== this.center)\n                    || (center.lat !== this.center.lat || center.lng !== this.center.lng)) {\n                    this.center = center;\n                    LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n                }\n            }\n        };\n        registerEventHandler('moveend', outputUpdateHandler);\n        registerEventHandler('zoomend', outputUpdateHandler);\n    }\n    /**\n     * Resize the map to fit it's parent container\n     */\n    doResize() {\n        // Run this outside of angular so the map events stay outside of angular\n        this.zone.runOutsideAngular(() => {\n            // Invalidate the map size to trigger it to update itself\n            if (null != this.map) {\n                this.map.invalidateSize({});\n            }\n        });\n    }\n    /**\n     * Manage a delayed resize of the component\n     */\n    delayResize() {\n        if (null != this.resizeTimer) {\n            clearTimeout(this.resizeTimer);\n        }\n        this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n    }\n    /**\n     * Set the view (center/zoom) all at once\n     * @param center The new center\n     * @param zoom The new zoom level\n     */\n    setView(center, zoom) {\n        if (null != this.map && null != center && null != zoom) {\n            this.map.setView(center, zoom, this.zoomPanOptions);\n        }\n    }\n    /**\n     * Set the map zoom level\n     * @param zoom the new zoom level for the map\n     */\n    setZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setZoom(zoom, this.zoomOptions);\n        }\n    }\n    /**\n     * Set the center of the map\n     * @param center the center point\n     */\n    setCenter(center) {\n        if (null != this.map && null != center) {\n            this.map.panTo(center, this.panOptions);\n        }\n    }\n    /**\n     * Fit the map to the bounds\n     * @param latLngBounds the boundary to set\n     */\n    setFitBounds(latLngBounds) {\n        if (null != this.map && null != latLngBounds) {\n            this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n        }\n    }\n    /**\n     * Set the map's max bounds\n     * @param latLngBounds the boundary to set\n     */\n    setMaxBounds(latLngBounds) {\n        if (null != this.map && null != latLngBounds) {\n            this.map.setMaxBounds(latLngBounds);\n        }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n    setMinZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setMinZoom(zoom);\n        }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n    setMaxZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setMaxZoom(zoom);\n        }\n    }\n}\nLeafletDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletDirective, selector: \"[leaflet]\", inputs: { fitBoundsOptions: [\"leafletFitBoundsOptions\", \"fitBoundsOptions\"], panOptions: [\"leafletPanOptions\", \"panOptions\"], zoomOptions: [\"leafletZoomOptions\", \"zoomOptions\"], zoomPanOptions: [\"leafletZoomPanOptions\", \"zoomPanOptions\"], options: [\"leafletOptions\", \"options\"], zoom: [\"leafletZoom\", \"zoom\"], center: [\"leafletCenter\", \"center\"], fitBounds: [\"leafletFitBounds\", \"fitBounds\"], maxBounds: [\"leafletMaxBounds\", \"maxBounds\"], minZoom: [\"leafletMinZoom\", \"minZoom\"], maxZoom: [\"leafletMaxZoom\", \"maxZoom\"] }, outputs: { mapReady: \"leafletMapReady\", zoomChange: \"leafletZoomChange\", centerChange: \"leafletCenterChange\", onClick: \"leafletClick\", onDoubleClick: \"leafletDoubleClick\", onMouseDown: \"leafletMouseDown\", onMouseUp: \"leafletMouseUp\", onMouseMove: \"leafletMouseMove\", onMouseOver: \"leafletMouseOver\", onMouseOut: \"leafletMouseOut\", onMapMove: \"leafletMapMove\", onMapMoveStart: \"leafletMapMoveStart\", onMapMoveEnd: \"leafletMapMoveEnd\", onMapZoom: \"leafletMapZoom\", onMapZoomStart: \"leafletMapZoomStart\", onMapZoomEnd: \"leafletMapZoomEnd\" }, host: { listeners: { \"window:resize\": \"onResize()\" } }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leaflet]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { fitBoundsOptions: [{\n                type: Input,\n                args: ['leafletFitBoundsOptions']\n            }], panOptions: [{\n                type: Input,\n                args: ['leafletPanOptions']\n            }], zoomOptions: [{\n                type: Input,\n                args: ['leafletZoomOptions']\n            }], zoomPanOptions: [{\n                type: Input,\n                args: ['leafletZoomPanOptions']\n            }], options: [{\n                type: Input,\n                args: ['leafletOptions']\n            }], mapReady: [{\n                type: Output,\n                args: ['leafletMapReady']\n            }], zoom: [{\n                type: Input,\n                args: ['leafletZoom']\n            }], zoomChange: [{\n                type: Output,\n                args: ['leafletZoomChange']\n            }], center: [{\n                type: Input,\n                args: ['leafletCenter']\n            }], centerChange: [{\n                type: Output,\n                args: ['leafletCenterChange']\n            }], fitBounds: [{\n                type: Input,\n                args: ['leafletFitBounds']\n            }], maxBounds: [{\n                type: Input,\n                args: ['leafletMaxBounds']\n            }], minZoom: [{\n                type: Input,\n                args: ['leafletMinZoom']\n            }], maxZoom: [{\n                type: Input,\n                args: ['leafletMaxZoom']\n            }], onClick: [{\n                type: Output,\n                args: ['leafletClick']\n            }], onDoubleClick: [{\n                type: Output,\n                args: ['leafletDoubleClick']\n            }], onMouseDown: [{\n                type: Output,\n                args: ['leafletMouseDown']\n            }], onMouseUp: [{\n                type: Output,\n                args: ['leafletMouseUp']\n            }], onMouseMove: [{\n                type: Output,\n                args: ['leafletMouseMove']\n            }], onMouseOver: [{\n                type: Output,\n                args: ['leafletMouseOver']\n            }], onMouseOut: [{\n                type: Output,\n                args: ['leafletMouseOut']\n            }], onMapMove: [{\n                type: Output,\n                args: ['leafletMapMove']\n            }], onMapMoveStart: [{\n                type: Output,\n                args: ['leafletMapMoveStart']\n            }], onMapMoveEnd: [{\n                type: Output,\n                args: ['leafletMapMoveEnd']\n            }], onMapZoom: [{\n                type: Output,\n                args: ['leafletMapZoom']\n            }], onMapZoomStart: [{\n                type: Output,\n                args: ['leafletMapZoomStart']\n            }], onMapZoomEnd: [{\n                type: Output,\n                args: ['leafletMapZoomEnd']\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }] } });\n\nclass LeafletDirectiveWrapper {\n    constructor(leafletDirective) {\n        this.leafletDirective = leafletDirective;\n    }\n    init() {\n        // Nothing for now\n    }\n    getMap() {\n        return this.leafletDirective.getMap();\n    }\n}\n\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\nclass LeafletLayerDirective {\n    constructor(leafletDirective, zone) {\n        this.zone = zone;\n        // Layer Events\n        this.onAdd = new EventEmitter();\n        this.onRemove = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n    }\n    ngOnDestroy() {\n        if (null != this.layer) {\n            // Unregister the event handlers\n            this.removeLayerEventListeners(this.layer);\n            // Remove the layer from the map\n            this.layer.remove();\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes['layer']) {\n            // Update the layer\n            const p = changes['layer'].previousValue;\n            const n = changes['layer'].currentValue;\n            this.zone.runOutsideAngular(() => {\n                if (null != p) {\n                    this.removeLayerEventListeners(p);\n                    p.remove();\n                }\n                if (null != n) {\n                    this.addLayerEventListeners(n);\n                    this.leafletDirective.getMap().addLayer(n);\n                }\n            });\n        }\n    }\n    addLayerEventListeners(l) {\n        this.onAddLayerHandler = (e) => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n        l.on('add', this.onAddLayerHandler);\n        this.onRemoveLayerHandler = (e) => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n        l.on('remove', this.onRemoveLayerHandler);\n    }\n    removeLayerEventListeners(l) {\n        l.off('add', this.onAddLayerHandler);\n        l.off('remove', this.onRemoveLayerHandler);\n    }\n}\nLeafletLayerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayerDirective, deps: [{ token: LeafletDirective }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletLayerDirective, selector: \"[leafletLayer]\", inputs: { layer: [\"leafletLayer\", \"layer\"] }, outputs: { onAdd: \"leafletLayerAdd\", onRemove: \"leafletLayerRemove\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayerDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayer]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.NgZone }]; }, propDecorators: { layer: [{\n                type: Input,\n                args: ['leafletLayer']\n            }], onAdd: [{\n                type: Output,\n                args: ['leafletLayerAdd']\n            }], onRemove: [{\n                type: Output,\n                args: ['leafletLayerRemove']\n            }] } });\n\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nclass LeafletLayersDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.layersDiffer = this.differs.find([]).create();\n    }\n    // Set/get the layers\n    set layers(v) {\n        this.layersValue = v;\n        // Now that we have a differ, do an immediate layer update\n        this.updateLayers();\n    }\n    get layers() {\n        return this.layersValue;\n    }\n    ngDoCheck() {\n        this.updateLayers();\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Update layers once the map is ready\n        this.updateLayers();\n    }\n    ngOnDestroy() {\n        this.layers = [];\n    }\n    /**\n     * Update the state of the layers.\n     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n     * This is important because it allows us to react to changes to the contents of the array as well\n     * as changes to the actual array instance.\n     */\n    updateLayers() {\n        const map = this.leafletDirective.getMap();\n        if (null != map && null != this.layersDiffer) {\n            const changes = this.layersDiffer.diff(this.layersValue);\n            if (null != changes) {\n                // Run outside angular to ensure layer events don't trigger change detection\n                this.zone.runOutsideAngular(() => {\n                    changes.forEachRemovedItem((c) => {\n                        map.removeLayer(c.item);\n                    });\n                    changes.forEachAddedItem((c) => {\n                        map.addLayer(c.item);\n                    });\n                });\n            }\n        }\n    }\n}\nLeafletLayersDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayersDirective, deps: [{ token: LeafletDirective }, { token: i0.IterableDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayersDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletLayersDirective, selector: \"[leafletLayers]\", inputs: { layers: [\"leafletLayers\", \"layers\"] }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayersDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayers]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.IterableDiffers }, { type: i0.NgZone }]; }, propDecorators: { layers: [{\n                type: Input,\n                args: ['leafletLayers']\n            }] } });\n\nclass LeafletControlLayersChanges {\n    constructor() {\n        this.layersRemoved = 0;\n        this.layersChanged = 0;\n        this.layersAdded = 0;\n    }\n    changed() {\n        return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n    }\n}\n\nclass LeafletControlLayersWrapper {\n    constructor(zone, layersControlReady) {\n        this.zone = zone;\n        this.layersControlReady = layersControlReady;\n    }\n    getLayersControl() {\n        return this.layersControl;\n    }\n    init(controlConfig, controlOptions) {\n        const baseLayers = controlConfig.baseLayers || {};\n        const overlays = controlConfig.overlays || {};\n        // Create the control outside of angular to ensure events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n            this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n        });\n        this.layersControlReady.emit(this.layersControl);\n        return this.layersControl;\n    }\n    applyBaseLayerChanges(changes) {\n        let results = new LeafletControlLayersChanges();\n        if (null != this.layersControl) {\n            results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n        }\n        return results;\n    }\n    applyOverlayChanges(changes) {\n        let results = new LeafletControlLayersChanges();\n        if (null != this.layersControl) {\n            results = this.applyChanges(changes, this.layersControl.addOverlay);\n        }\n        return results;\n    }\n    applyChanges(changes, addFn) {\n        const results = new LeafletControlLayersChanges();\n        if (null != changes) {\n            // All layer management is outside angular to avoid layer events from triggering change detection\n            this.zone.runOutsideAngular(() => {\n                changes.forEachChangedItem((c) => {\n                    this.layersControl.removeLayer(c.previousValue);\n                    addFn.call(this.layersControl, c.currentValue, c.key);\n                    results.layersChanged++;\n                });\n                changes.forEachRemovedItem((c) => {\n                    this.layersControl.removeLayer(c.previousValue);\n                    results.layersRemoved++;\n                });\n                changes.forEachAddedItem((c) => {\n                    addFn.call(this.layersControl, c.currentValue, c.key);\n                    results.layersAdded++;\n                });\n            });\n        }\n        return results;\n    }\n}\n\nclass LeafletControlLayersConfig {\n    constructor() {\n        this.baseLayers = {};\n        this.overlays = {};\n    }\n}\n\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\nclass LeafletLayersControlDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        // Generate differs\n        this.baseLayersDiffer = this.differs.find({}).create();\n        this.overlaysDiffer = this.differs.find({}).create();\n    }\n    set layersControlConfig(v) {\n        // Validation/init stuff\n        if (null == v) {\n            v = new LeafletControlLayersConfig();\n        }\n        if (null == v.baseLayers) {\n            v.baseLayers = {};\n        }\n        if (null == v.overlays) {\n            v.overlays = {};\n        }\n        // Store the value\n        this.layersControlConfigValue = v;\n        // Update the map\n        this.updateLayers();\n    }\n    get layersControlConfig() {\n        return this.layersControlConfigValue;\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Set up control outside of angular to avoid change detection when using the control\n        this.zone.runOutsideAngular(() => {\n            // Set up all the initial settings\n            this.controlLayers\n                .init({}, this.layersControlOptions)\n                .addTo(this.leafletDirective.getMap());\n        });\n        this.updateLayers();\n    }\n    ngOnDestroy() {\n        this.layersControlConfig = { baseLayers: {}, overlays: {} };\n        this.controlLayers.getLayersControl().remove();\n    }\n    ngDoCheck() {\n        this.updateLayers();\n    }\n    updateLayers() {\n        const map = this.leafletDirective.getMap();\n        const layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl) {\n            // Run the baselayers differ\n            if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n                const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n                this.controlLayers.applyBaseLayerChanges(changes);\n            }\n            // Run the overlays differ\n            if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n                const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n                this.controlLayers.applyOverlayChanges(changes);\n            }\n        }\n    }\n}\nLeafletLayersControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayersControlDirective, deps: [{ token: LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayersControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletLayersControlDirective, selector: \"[leafletLayersControl]\", inputs: { layersControlConfig: [\"leafletLayersControl\", \"layersControlConfig\"], layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"] }, outputs: { layersControlReady: \"leafletLayersControlReady\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayersControlDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayersControl]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }]; }, propDecorators: { layersControlConfig: [{\n                type: Input,\n                args: ['leafletLayersControl']\n            }], layersControlOptions: [{\n                type: Input,\n                args: ['leafletLayersControlOptions']\n            }], layersControlReady: [{\n                type: Output,\n                args: ['leafletLayersControlReady']\n            }] } });\n\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\nclass LeafletBaseLayersDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        // Output for once the layers control is ready\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        this.baseLayersDiffer = this.differs.find({}).create();\n    }\n    // Set/get baseLayers\n    set baseLayers(v) {\n        this.baseLayersValue = v;\n        this.updateBaseLayers();\n    }\n    get baseLayers() {\n        return this.baseLayersValue;\n    }\n    ngOnDestroy() {\n        this.baseLayers = {};\n        if (null != this.controlLayers.getLayersControl()) {\n            this.controlLayers.getLayersControl().remove();\n        }\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Create the control outside angular to prevent events from triggering chnage detection\n        this.zone.runOutsideAngular(() => {\n            // Initially configure the controlLayers\n            this.controlLayers\n                .init({}, this.layersControlOptions)\n                .addTo(this.leafletDirective.getMap());\n        });\n        this.updateBaseLayers();\n    }\n    ngDoCheck() {\n        this.updateBaseLayers();\n    }\n    updateBaseLayers() {\n        const map = this.leafletDirective.getMap();\n        const layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n            const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n            const results = this.controlLayers.applyBaseLayerChanges(changes);\n            if (results.changed()) {\n                this.syncBaseLayer();\n            }\n        }\n    }\n    /**\n     * Check the current base layer and change it to the new one if necessary\n     */\n    syncBaseLayer() {\n        const map = this.leafletDirective.getMap();\n        const layers = LeafletUtil.mapToArray(this.baseLayers);\n        let foundLayer;\n        // Search all the layers in the map to see if we can find them in the baselayer array\n        map.eachLayer((l) => {\n            foundLayer = layers.find((bl) => (l === bl));\n        });\n        // Did we find the layer?\n        if (null != foundLayer) {\n            // Yes - set the baselayer to the one we found\n            this.baseLayer = foundLayer;\n        }\n        else {\n            // No - set the baselayer to the first in the array and add it to the map\n            if (layers.length > 0) {\n                this.baseLayer = layers[0];\n                // Add layers outside of angular to prevent events from triggering change detection\n                this.zone.runOutsideAngular(() => {\n                    this.baseLayer.addTo(map);\n                });\n            }\n        }\n    }\n}\nLeafletBaseLayersDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletBaseLayersDirective, deps: [{ token: LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletBaseLayersDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletBaseLayersDirective, selector: \"[leafletBaseLayers]\", inputs: { baseLayers: [\"leafletBaseLayers\", \"baseLayers\"], layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"] }, outputs: { layersControlReady: \"leafletLayersControlReady\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletBaseLayersDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletBaseLayers]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }]; }, propDecorators: { baseLayers: [{\n                type: Input,\n                args: ['leafletBaseLayers']\n            }], layersControlOptions: [{\n                type: Input,\n                args: ['leafletLayersControlOptions']\n            }], layersControlReady: [{\n                type: Output,\n                args: ['leafletLayersControlReady']\n            }] } });\n\nclass LeafletModule {\n}\nLeafletModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nLeafletModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletModule, declarations: [LeafletDirective,\n        LeafletLayerDirective,\n        LeafletLayersDirective,\n        LeafletLayersControlDirective,\n        LeafletBaseLayersDirective], exports: [LeafletDirective,\n        LeafletLayerDirective,\n        LeafletLayersDirective,\n        LeafletLayersControlDirective,\n        LeafletBaseLayersDirective] });\nLeafletModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [\n                        LeafletDirective,\n                        LeafletLayerDirective,\n                        LeafletLayersDirective,\n                        LeafletLayersControlDirective,\n                        LeafletBaseLayersDirective\n                    ],\n                    declarations: [\n                        LeafletDirective,\n                        LeafletLayerDirective,\n                        LeafletLayersDirective,\n                        LeafletLayersControlDirective,\n                        LeafletBaseLayersDirective\n                    ]\n                }]\n        }] });\n\nclass LeafletTileLayerDefinition {\n    constructor(type, url, options) {\n        this.type = type;\n        this.url = url;\n        this.options = options;\n    }\n    /**\n     * Creates a TileLayer from the provided definition. This is a convenience function\n     * to help with generating layers from objects.\n     *\n     * @param layerDef The layer to create\n     * @returns {TileLayer} The TileLayer that has been created\n     */\n    static createTileLayer(layerDef) {\n        let layer;\n        switch (layerDef.type) {\n            case 'xyz':\n                layer = tileLayer(layerDef.url, layerDef.options);\n                break;\n            case 'wms':\n            default:\n                layer = tileLayer.wms(layerDef.url, layerDef.options);\n                break;\n        }\n        return layer;\n    }\n    /**\n     * Creates a TileLayer for each key in the incoming map. This is a convenience function\n     * for generating an associative array of layers from an associative array of objects\n     *\n     * @param layerDefs A map of key to tile layer definition\n     * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n     */\n    static createTileLayers(layerDefs) {\n        const layers = {};\n        for (const k in layerDefs) {\n            if (layerDefs.hasOwnProperty(k)) {\n                layers[k] = (LeafletTileLayerDefinition.createTileLayer(layerDefs[k]));\n            }\n        }\n        return layers;\n    }\n    /**\n     * Create a Tile Layer from the current state of this object\n     *\n     * @returns {TileLayer} A new TileLayer\n     */\n    createTileLayer() {\n        return LeafletTileLayerDefinition.createTileLayer(this);\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil };\n//# sourceMappingURL=asymmetrik-ngx-leaflet.mjs.map\n"],"mappings":"AAAA,OAAO,KAAKA,EAAE,MAAM,eAAe;AACnC,SAASC,YAAY,EAAEC,SAAS,EAAEC,KAAK,EAAEC,MAAM,EAAEC,YAAY,EAAEC,QAAQ,QAAQ,eAAe;AAC9F,SAASC,MAAM,EAAEC,GAAG,EAAEC,OAAO,EAAEC,SAAS,QAAQ,SAAS;AAEzD,MAAMC,WAAW,CAAC;EACd,OAAOC,UAAU,CAACJ,GAAG,EAAE;IACnB,MAAMK,QAAQ,GAAG,EAAE;IACnB,KAAK,MAAMC,CAAC,IAAIN,GAAG,EAAE;MACjB,IAAIA,GAAG,CAACO,cAAc,CAACD,CAAC,CAAC,EAAE;QACvBD,QAAQ,CAACG,IAAI,CAACR,GAAG,CAACM,CAAC,CAAC,CAAC;MACzB;IACJ;IACA,OAAOD,QAAQ;EACnB;EACA,OAAOI,WAAW,CAACC,IAAI,EAAEC,YAAY,EAAEC,KAAK,EAAE;IAC1C;IACA,IAAI,CAAC,GAAGD,YAAY,CAACE,SAAS,CAACC,MAAM,EAAE;MACnCJ,IAAI,CAACK,GAAG,CAAC,MAAM;QACXJ,YAAY,CAACK,IAAI,CAACJ,KAAK,CAAC;MAC5B,CAAC,CAAC;IACN;EACJ;AACJ;AAEA,MAAMK,gBAAgB,CAAC;EACnBC,WAAW,CAACC,OAAO,EAAET,IAAI,EAAE;IACvB,IAAI,CAACS,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACU,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,cAAc,GAAGtB,MAAM,CAAC,SAAS,EAAE,CAAC,SAAS,CAAC;IACnD,IAAI,CAACuB,mBAAmB,GAAG,CAAC,CAAC;IAC7B,IAAI,CAACC,gBAAgB,GAAG,IAAI,CAACD,mBAAmB;IAChD,IAAI,CAACE,UAAU,GAAG,IAAI,CAACF,mBAAmB;IAC1C,IAAI,CAACG,WAAW,GAAG,IAAI,CAACH,mBAAmB;IAC3C,IAAI,CAACI,cAAc,GAAG,IAAI,CAACJ,mBAAmB;IAC9C;IACA,IAAI,CAACK,OAAO,GAAG,CAAC,CAAC;IACjB;IACA,IAAI,CAACC,QAAQ,GAAG,IAAInC,YAAY,EAAE;IAClC,IAAI,CAACoC,UAAU,GAAG,IAAIpC,YAAY,EAAE;IACpC,IAAI,CAACqC,YAAY,GAAG,IAAIrC,YAAY,EAAE;IACtC;IACA,IAAI,CAACsC,OAAO,GAAG,IAAItC,YAAY,EAAE;IACjC,IAAI,CAACuC,aAAa,GAAG,IAAIvC,YAAY,EAAE;IACvC,IAAI,CAACwC,WAAW,GAAG,IAAIxC,YAAY,EAAE;IACrC,IAAI,CAACyC,SAAS,GAAG,IAAIzC,YAAY,EAAE;IACnC,IAAI,CAAC0C,WAAW,GAAG,IAAI1C,YAAY,EAAE;IACrC,IAAI,CAAC2C,WAAW,GAAG,IAAI3C,YAAY,EAAE;IACrC,IAAI,CAAC4C,UAAU,GAAG,IAAI5C,YAAY,EAAE;IACpC;IACA,IAAI,CAAC6C,SAAS,GAAG,IAAI7C,YAAY,EAAE;IACnC,IAAI,CAAC8C,cAAc,GAAG,IAAI9C,YAAY,EAAE;IACxC,IAAI,CAAC+C,YAAY,GAAG,IAAI/C,YAAY,EAAE;IACtC;IACA,IAAI,CAACgD,SAAS,GAAG,IAAIhD,YAAY,EAAE;IACnC,IAAI,CAACiD,cAAc,GAAG,IAAIjD,YAAY,EAAE;IACxC,IAAI,CAACkD,YAAY,GAAG,IAAIlD,YAAY,EAAE;IACtC;EACJ;;EACAmD,QAAQ,GAAG;IACP;IACA,IAAI,CAAClC,IAAI,CAACmC,iBAAiB,CAAC,MAAM;MAC9B;MACA,IAAI,CAAC7C,GAAG,GAAGA,GAAG,CAAC,IAAI,CAACmB,OAAO,CAAC2B,aAAa,EAAE,IAAI,CAACnB,OAAO,CAAC;MACxD,IAAI,CAACoB,oBAAoB,EAAE;IAC/B,CAAC,CAAC;IACF;IACA,IAAI,IAAI,IAAI,IAAI,CAACC,MAAM,IAAI,IAAI,IAAI,IAAI,CAACC,IAAI,EAAE;MAC1C,IAAI,CAACC,OAAO,CAAC,IAAI,CAACF,MAAM,EAAE,IAAI,CAACC,IAAI,CAAC;IACxC;IACA;IACA,IAAI,IAAI,IAAI,IAAI,CAACE,SAAS,EAAE;MACxB,IAAI,CAACC,YAAY,CAAC,IAAI,CAACD,SAAS,CAAC;IACrC;IACA,IAAI,IAAI,IAAI,IAAI,CAACE,SAAS,EAAE;MACxB,IAAI,CAACC,YAAY,CAAC,IAAI,CAACD,SAAS,CAAC;IACrC;IACA,IAAI,IAAI,IAAI,IAAI,CAACE,OAAO,EAAE;MACtB,IAAI,CAACC,UAAU,CAAC,IAAI,CAACD,OAAO,CAAC;IACjC;IACA,IAAI,IAAI,IAAI,IAAI,CAACE,OAAO,EAAE;MACtB,IAAI,CAACC,UAAU,CAAC,IAAI,CAACD,OAAO,CAAC;IACjC;IACA,IAAI,CAACE,QAAQ,EAAE;IACf;IACA,IAAI,CAAC/B,QAAQ,CAACZ,IAAI,CAAC,IAAI,CAAChB,GAAG,CAAC;EAChC;EACA4D,WAAW,CAACC,OAAO,EAAE;IACjB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ;IACA,IAAIA,OAAO,CAAC,MAAM,CAAC,IAAIA,OAAO,CAAC,QAAQ,CAAC,IAAI,IAAI,IAAI,IAAI,CAACZ,IAAI,IAAI,IAAI,IAAI,IAAI,CAACD,MAAM,EAAE;MAClF,IAAI,CAACE,OAAO,CAACW,OAAO,CAAC,QAAQ,CAAC,CAACC,YAAY,EAAED,OAAO,CAAC,MAAM,CAAC,CAACC,YAAY,CAAC;IAC9E;IACA;IAAA,KACK,IAAID,OAAO,CAAC,MAAM,CAAC,EAAE;MACtB,IAAI,CAACE,OAAO,CAACF,OAAO,CAAC,MAAM,CAAC,CAACC,YAAY,CAAC;IAC9C;IACA;IAAA,KACK,IAAID,OAAO,CAAC,QAAQ,CAAC,EAAE;MACxB,IAAI,CAACG,SAAS,CAACH,OAAO,CAAC,QAAQ,CAAC,CAACC,YAAY,CAAC;IAClD;IACA;IACA,IAAID,OAAO,CAAC,WAAW,CAAC,EAAE;MACtB,IAAI,CAACT,YAAY,CAACS,OAAO,CAAC,WAAW,CAAC,CAACC,YAAY,CAAC;IACxD;IACA,IAAID,OAAO,CAAC,WAAW,CAAC,EAAE;MACtB,IAAI,CAACP,YAAY,CAACO,OAAO,CAAC,WAAW,CAAC,CAACC,YAAY,CAAC;IACxD;IACA,IAAID,OAAO,CAAC,SAAS,CAAC,EAAE;MACpB,IAAI,CAACL,UAAU,CAACK,OAAO,CAAC,SAAS,CAAC,CAACC,YAAY,CAAC;IACpD;IACA,IAAID,OAAO,CAAC,SAAS,CAAC,EAAE;MACpB,IAAI,CAACH,UAAU,CAACG,OAAO,CAAC,SAAS,CAAC,CAACC,YAAY,CAAC;IACpD;EACJ;EACAG,WAAW,GAAG;IACV;IACA,IAAI,IAAI,IAAI,IAAI,CAACjE,GAAG,EAAE;MAClB,IAAI,CAACA,GAAG,CAACkE,MAAM,EAAE;IACrB;EACJ;EACAC,MAAM,GAAG;IACL,OAAO,IAAI,CAACnE,GAAG;EACnB;EACAoE,QAAQ,GAAG;IACP,IAAI,CAACC,WAAW,EAAE;EACtB;EACAtB,oBAAoB,GAAG;IACnB,MAAMuB,oBAAoB,GAAG,CAACC,SAAS,EAAEC,OAAO,KAAK;MACjD,IAAI,CAACxE,GAAG,CAACyE,EAAE,CAACF,SAAS,EAAEC,OAAO,CAAC;IACnC,CAAC;IACD;IACAF,oBAAoB,CAAC,OAAO,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACqB,OAAO,EAAE2C,CAAC,CAAC,CAAC;IACzFJ,oBAAoB,CAAC,UAAU,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACsB,aAAa,EAAE0C,CAAC,CAAC,CAAC;IAClGJ,oBAAoB,CAAC,WAAW,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACuB,WAAW,EAAEyC,CAAC,CAAC,CAAC;IACjGJ,oBAAoB,CAAC,SAAS,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACwB,SAAS,EAAEwC,CAAC,CAAC,CAAC;IAC7FJ,oBAAoB,CAAC,WAAW,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC0B,WAAW,EAAEsC,CAAC,CAAC,CAAC;IACjGJ,oBAAoB,CAAC,UAAU,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC2B,UAAU,EAAEqC,CAAC,CAAC,CAAC;IAC/FJ,oBAAoB,CAAC,WAAW,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACyB,WAAW,EAAEuC,CAAC,CAAC,CAAC;IACjGJ,oBAAoB,CAAC,WAAW,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACgC,cAAc,EAAEgC,CAAC,CAAC,CAAC;IACpGJ,oBAAoB,CAAC,MAAM,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC+B,SAAS,EAAEiC,CAAC,CAAC,CAAC;IAC1FJ,oBAAoB,CAAC,SAAS,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACiC,YAAY,EAAE+B,CAAC,CAAC,CAAC;IAChGJ,oBAAoB,CAAC,WAAW,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC6B,cAAc,EAAEmC,CAAC,CAAC,CAAC;IACpGJ,oBAAoB,CAAC,MAAM,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC4B,SAAS,EAAEoC,CAAC,CAAC,CAAC;IAC1FJ,oBAAoB,CAAC,SAAS,EAAGI,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC8B,YAAY,EAAEkC,CAAC,CAAC,CAAC;IAChG;IACA,MAAMC,mBAAmB,GAAG,MAAM;MAC9B,MAAM1B,IAAI,GAAG,IAAI,CAACjD,GAAG,CAAC4E,OAAO,EAAE;MAC/B,IAAI3B,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;QACpB,IAAI,CAACA,IAAI,GAAGA,IAAI;QAChB9C,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACmB,UAAU,EAAEoB,IAAI,CAAC;MAC7D;MACA,MAAMD,MAAM,GAAG,IAAI,CAAChD,GAAG,CAAC6E,SAAS,EAAE;MACnC,IAAI,IAAI,IAAI7B,MAAM,IAAI,IAAI,IAAI,IAAI,CAACA,MAAM,EAAE;QACvC,IAAK,CAAC,IAAI,IAAIA,MAAM,IAAI,IAAI,IAAI,IAAI,CAACA,MAAM,KAAKA,MAAM,KAAK,IAAI,CAACA,MAAM,IAC9DA,MAAM,CAAC8B,GAAG,KAAK,IAAI,CAAC9B,MAAM,CAAC8B,GAAG,IAAI9B,MAAM,CAAC+B,GAAG,KAAK,IAAI,CAAC/B,MAAM,CAAC+B,GAAI,EAAE;UACvE,IAAI,CAAC/B,MAAM,GAAGA,MAAM;UACpB7C,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACoB,YAAY,EAAEkB,MAAM,CAAC;QACjE;MACJ;IACJ,CAAC;IACDsB,oBAAoB,CAAC,SAAS,EAAEK,mBAAmB,CAAC;IACpDL,oBAAoB,CAAC,SAAS,EAAEK,mBAAmB,CAAC;EACxD;EACA;AACJ;AACA;EACIhB,QAAQ,GAAG;IACP;IACA,IAAI,CAACjD,IAAI,CAACmC,iBAAiB,CAAC,MAAM;MAC9B;MACA,IAAI,IAAI,IAAI,IAAI,CAAC7C,GAAG,EAAE;QAClB,IAAI,CAACA,GAAG,CAACgF,cAAc,CAAC,CAAC,CAAC,CAAC;MAC/B;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIX,WAAW,GAAG;IACV,IAAI,IAAI,IAAI,IAAI,CAACY,WAAW,EAAE;MAC1BC,YAAY,CAAC,IAAI,CAACD,WAAW,CAAC;IAClC;IACA,IAAI,CAACA,WAAW,GAAGE,UAAU,CAAC,IAAI,CAACxB,QAAQ,CAACyB,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC;EAChE;EACA;AACJ;AACA;AACA;AACA;EACIlC,OAAO,CAACF,MAAM,EAAEC,IAAI,EAAE;IAClB,IAAI,IAAI,IAAI,IAAI,CAACjD,GAAG,IAAI,IAAI,IAAIgD,MAAM,IAAI,IAAI,IAAIC,IAAI,EAAE;MACpD,IAAI,CAACjD,GAAG,CAACkD,OAAO,CAACF,MAAM,EAAEC,IAAI,EAAE,IAAI,CAACvB,cAAc,CAAC;IACvD;EACJ;EACA;AACJ;AACA;AACA;EACIqC,OAAO,CAACd,IAAI,EAAE;IACV,IAAI,IAAI,IAAI,IAAI,CAACjD,GAAG,IAAI,IAAI,IAAIiD,IAAI,EAAE;MAClC,IAAI,CAACjD,GAAG,CAAC+D,OAAO,CAACd,IAAI,EAAE,IAAI,CAACxB,WAAW,CAAC;IAC5C;EACJ;EACA;AACJ;AACA;AACA;EACIuC,SAAS,CAAChB,MAAM,EAAE;IACd,IAAI,IAAI,IAAI,IAAI,CAAChD,GAAG,IAAI,IAAI,IAAIgD,MAAM,EAAE;MACpC,IAAI,CAAChD,GAAG,CAACqF,KAAK,CAACrC,MAAM,EAAE,IAAI,CAACxB,UAAU,CAAC;IAC3C;EACJ;EACA;AACJ;AACA;AACA;EACI4B,YAAY,CAACkC,YAAY,EAAE;IACvB,IAAI,IAAI,IAAI,IAAI,CAACtF,GAAG,IAAI,IAAI,IAAIsF,YAAY,EAAE;MAC1C,IAAI,CAACtF,GAAG,CAACmD,SAAS,CAACmC,YAAY,EAAE,IAAI,CAAC/D,gBAAgB,CAAC;IAC3D;EACJ;EACA;AACJ;AACA;AACA;EACI+B,YAAY,CAACgC,YAAY,EAAE;IACvB,IAAI,IAAI,IAAI,IAAI,CAACtF,GAAG,IAAI,IAAI,IAAIsF,YAAY,EAAE;MAC1C,IAAI,CAACtF,GAAG,CAACsD,YAAY,CAACgC,YAAY,CAAC;IACvC;EACJ;EACA;AACJ;AACA;AACA;EACI9B,UAAU,CAACP,IAAI,EAAE;IACb,IAAI,IAAI,IAAI,IAAI,CAACjD,GAAG,IAAI,IAAI,IAAIiD,IAAI,EAAE;MAClC,IAAI,CAACjD,GAAG,CAACwD,UAAU,CAACP,IAAI,CAAC;IAC7B;EACJ;EACA;AACJ;AACA;AACA;EACIS,UAAU,CAACT,IAAI,EAAE;IACb,IAAI,IAAI,IAAI,IAAI,CAACjD,GAAG,IAAI,IAAI,IAAIiD,IAAI,EAAE;MAClC,IAAI,CAACjD,GAAG,CAAC0D,UAAU,CAACT,IAAI,CAAC;IAC7B;EACJ;AACJ;AACAhC,gBAAgB,CAACsE,IAAI;EAAA,iBAAwFtE,gBAAgB,EAA1BzB,EAAE,mBAA0CA,EAAE,CAACgG,UAAU,GAAzDhG,EAAE,mBAAoEA,EAAE,CAACiG,MAAM;AAAA,CAA4C;AAC9NxE,gBAAgB,CAACyE,IAAI,kBAD8ElG,EAAE;EAAA,MACJyB,gBAAgB;EAAA;EAAA;IAAA;MADdzB,EAAE;QAAA,OACJ,cAAU;MAAA,UADRA,EAAE;IAAA;EAAA;EAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;EAAA;EAAA,WAAFA,EAAE;AAAA,EACqqC;AAC1wC;EAAA,mDAFmGA,EAAE,mBAEVyB,gBAAgB,EAAc,CAAC;IAC9G0E,IAAI,EAAEjG,SAAS;IACfkG,IAAI,EAAE,CAAC;MACCC,QAAQ,EAAE;IACd,CAAC;EACT,CAAC,CAAC,EAAkB,YAAY;IAAE,OAAO,CAAC;MAAEF,IAAI,EAAEnG,EAAE,CAACgG;IAAW,CAAC,EAAE;MAAEG,IAAI,EAAEnG,EAAE,CAACiG;IAAO,CAAC,CAAC;EAAE,CAAC,EAAkB;IAAElE,gBAAgB,EAAE,CAAC;MACzHoE,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,yBAAyB;IACpC,CAAC,CAAC;IAAEpE,UAAU,EAAE,CAAC;MACbmE,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,mBAAmB;IAC9B,CAAC,CAAC;IAAEnE,WAAW,EAAE,CAAC;MACdkE,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,oBAAoB;IAC/B,CAAC,CAAC;IAAElE,cAAc,EAAE,CAAC;MACjBiE,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,uBAAuB;IAClC,CAAC,CAAC;IAAEjE,OAAO,EAAE,CAAC;MACVgE,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,gBAAgB;IAC3B,CAAC,CAAC;IAAEhE,QAAQ,EAAE,CAAC;MACX+D,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,iBAAiB;IAC5B,CAAC,CAAC;IAAE3C,IAAI,EAAE,CAAC;MACP0C,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,aAAa;IACxB,CAAC,CAAC;IAAE/D,UAAU,EAAE,CAAC;MACb8D,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,mBAAmB;IAC9B,CAAC,CAAC;IAAE5C,MAAM,EAAE,CAAC;MACT2C,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,eAAe;IAC1B,CAAC,CAAC;IAAE9D,YAAY,EAAE,CAAC;MACf6D,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,qBAAqB;IAChC,CAAC,CAAC;IAAEzC,SAAS,EAAE,CAAC;MACZwC,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,kBAAkB;IAC7B,CAAC,CAAC;IAAEvC,SAAS,EAAE,CAAC;MACZsC,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,kBAAkB;IAC7B,CAAC,CAAC;IAAErC,OAAO,EAAE,CAAC;MACVoC,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,gBAAgB;IAC3B,CAAC,CAAC;IAAEnC,OAAO,EAAE,CAAC;MACVkC,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,gBAAgB;IAC3B,CAAC,CAAC;IAAE7D,OAAO,EAAE,CAAC;MACV4D,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,cAAc;IACzB,CAAC,CAAC;IAAE5D,aAAa,EAAE,CAAC;MAChB2D,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,oBAAoB;IAC/B,CAAC,CAAC;IAAE3D,WAAW,EAAE,CAAC;MACd0D,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,kBAAkB;IAC7B,CAAC,CAAC;IAAE1D,SAAS,EAAE,CAAC;MACZyD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,gBAAgB;IAC3B,CAAC,CAAC;IAAEzD,WAAW,EAAE,CAAC;MACdwD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,kBAAkB;IAC7B,CAAC,CAAC;IAAExD,WAAW,EAAE,CAAC;MACduD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,kBAAkB;IAC7B,CAAC,CAAC;IAAEvD,UAAU,EAAE,CAAC;MACbsD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,iBAAiB;IAC5B,CAAC,CAAC;IAAEtD,SAAS,EAAE,CAAC;MACZqD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,gBAAgB;IAC3B,CAAC,CAAC;IAAErD,cAAc,EAAE,CAAC;MACjBoD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,qBAAqB;IAChC,CAAC,CAAC;IAAEpD,YAAY,EAAE,CAAC;MACfmD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,mBAAmB;IAC9B,CAAC,CAAC;IAAEnD,SAAS,EAAE,CAAC;MACZkD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,gBAAgB;IAC3B,CAAC,CAAC;IAAElD,cAAc,EAAE,CAAC;MACjBiD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,qBAAqB;IAChC,CAAC,CAAC;IAAEjD,YAAY,EAAE,CAAC;MACfgD,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,mBAAmB;IAC9B,CAAC,CAAC;IAAExB,QAAQ,EAAE,CAAC;MACXuB,IAAI,EAAE9F,YAAY;MAClB+F,IAAI,EAAE,CAAC,eAAe,EAAE,EAAE;IAC9B,CAAC;EAAE,CAAC;AAAA;AAEhB,MAAME,uBAAuB,CAAC;EAC1B5E,WAAW,CAAC6E,gBAAgB,EAAE;IAC1B,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;EAC5C;EACAC,IAAI,GAAG;IACH;EAAA;EAEJ7B,MAAM,GAAG;IACL,OAAO,IAAI,CAAC4B,gBAAgB,CAAC5B,MAAM,EAAE;EACzC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM8B,qBAAqB,CAAC;EACxB/E,WAAW,CAAC6E,gBAAgB,EAAErF,IAAI,EAAE;IAChC,IAAI,CAACA,IAAI,GAAGA,IAAI;IAChB;IACA,IAAI,CAACwF,KAAK,GAAG,IAAIzG,YAAY,EAAE;IAC/B,IAAI,CAAC0G,QAAQ,GAAG,IAAI1G,YAAY,EAAE;IAClC,IAAI,CAACsG,gBAAgB,GAAG,IAAID,uBAAuB,CAACC,gBAAgB,CAAC;EACzE;EACAnD,QAAQ,GAAG;IACP;IACA,IAAI,CAACmD,gBAAgB,CAACC,IAAI,EAAE;EAChC;EACA/B,WAAW,GAAG;IACV,IAAI,IAAI,IAAI,IAAI,CAACmC,KAAK,EAAE;MACpB;MACA,IAAI,CAACC,yBAAyB,CAAC,IAAI,CAACD,KAAK,CAAC;MAC1C;MACA,IAAI,CAACA,KAAK,CAAClC,MAAM,EAAE;IACvB;EACJ;EACAN,WAAW,CAACC,OAAO,EAAE;IACjB,IAAIA,OAAO,CAAC,OAAO,CAAC,EAAE;MAClB;MACA,MAAMyC,CAAC,GAAGzC,OAAO,CAAC,OAAO,CAAC,CAAC0C,aAAa;MACxC,MAAMC,CAAC,GAAG3C,OAAO,CAAC,OAAO,CAAC,CAACC,YAAY;MACvC,IAAI,CAACpD,IAAI,CAACmC,iBAAiB,CAAC,MAAM;QAC9B,IAAI,IAAI,IAAIyD,CAAC,EAAE;UACX,IAAI,CAACD,yBAAyB,CAACC,CAAC,CAAC;UACjCA,CAAC,CAACpC,MAAM,EAAE;QACd;QACA,IAAI,IAAI,IAAIsC,CAAC,EAAE;UACX,IAAI,CAACC,sBAAsB,CAACD,CAAC,CAAC;UAC9B,IAAI,CAACT,gBAAgB,CAAC5B,MAAM,EAAE,CAACuC,QAAQ,CAACF,CAAC,CAAC;QAC9C;MACJ,CAAC,CAAC;IACN;EACJ;EACAC,sBAAsB,CAACE,CAAC,EAAE;IACtB,IAAI,CAACC,iBAAiB,GAAIlC,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACwF,KAAK,EAAExB,CAAC,CAAC;IACjFiC,CAAC,CAAClC,EAAE,CAAC,KAAK,EAAE,IAAI,CAACmC,iBAAiB,CAAC;IACnC,IAAI,CAACC,oBAAoB,GAAInC,CAAC,IAAKvE,WAAW,CAACM,WAAW,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACyF,QAAQ,EAAEzB,CAAC,CAAC;IACvFiC,CAAC,CAAClC,EAAE,CAAC,QAAQ,EAAE,IAAI,CAACoC,oBAAoB,CAAC;EAC7C;EACAR,yBAAyB,CAACM,CAAC,EAAE;IACzBA,CAAC,CAACG,GAAG,CAAC,KAAK,EAAE,IAAI,CAACF,iBAAiB,CAAC;IACpCD,CAAC,CAACG,GAAG,CAAC,QAAQ,EAAE,IAAI,CAACD,oBAAoB,CAAC;EAC9C;AACJ;AACAZ,qBAAqB,CAACV,IAAI;EAAA,iBAAwFU,qBAAqB,EAhKpCzG,EAAE,mBAgKoDyB,gBAAgB,GAhKtEzB,EAAE,mBAgKiFA,EAAE,CAACiG,MAAM;AAAA,CAA4C;AAC3OQ,qBAAqB,CAACP,IAAI,kBAjKyElG,EAAE;EAAA,MAiKCyG,qBAAqB;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA,WAjKxBzG,EAAE;AAAA,EAiK6M;AAClT;EAAA,mDAlKmGA,EAAE,mBAkKVyG,qBAAqB,EAAc,CAAC;IACnHN,IAAI,EAAEjG,SAAS;IACfkG,IAAI,EAAE,CAAC;MACCC,QAAQ,EAAE;IACd,CAAC;EACT,CAAC,CAAC,EAAkB,YAAY;IAAE,OAAO,CAAC;MAAEF,IAAI,EAAE1E;IAAiB,CAAC,EAAE;MAAE0E,IAAI,EAAEnG,EAAE,CAACiG;IAAO,CAAC,CAAC;EAAE,CAAC,EAAkB;IAAEW,KAAK,EAAE,CAAC;MACjHT,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,cAAc;IACzB,CAAC,CAAC;IAAEM,KAAK,EAAE,CAAC;MACRP,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,iBAAiB;IAC5B,CAAC,CAAC;IAAEO,QAAQ,EAAE,CAAC;MACXR,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,oBAAoB;IAC/B,CAAC;EAAE,CAAC;AAAA;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMmB,sBAAsB,CAAC;EACzB7F,WAAW,CAAC6E,gBAAgB,EAAEiB,OAAO,EAAEtG,IAAI,EAAE;IACzC,IAAI,CAACsG,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACtG,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACqF,gBAAgB,GAAG,IAAID,uBAAuB,CAACC,gBAAgB,CAAC;IACrE,IAAI,CAACkB,YAAY,GAAG,IAAI,CAACD,OAAO,CAACE,IAAI,CAAC,EAAE,CAAC,CAACC,MAAM,EAAE;EACtD;EACA;EACA,IAAIC,MAAM,CAACC,CAAC,EAAE;IACV,IAAI,CAACC,WAAW,GAAGD,CAAC;IACpB;IACA,IAAI,CAACE,YAAY,EAAE;EACvB;EACA,IAAIH,MAAM,GAAG;IACT,OAAO,IAAI,CAACE,WAAW;EAC3B;EACAE,SAAS,GAAG;IACR,IAAI,CAACD,YAAY,EAAE;EACvB;EACA3E,QAAQ,GAAG;IACP;IACA,IAAI,CAACmD,gBAAgB,CAACC,IAAI,EAAE;IAC5B;IACA,IAAI,CAACuB,YAAY,EAAE;EACvB;EACAtD,WAAW,GAAG;IACV,IAAI,CAACmD,MAAM,GAAG,EAAE;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIG,YAAY,GAAG;IACX,MAAMvH,GAAG,GAAG,IAAI,CAAC+F,gBAAgB,CAAC5B,MAAM,EAAE;IAC1C,IAAI,IAAI,IAAInE,GAAG,IAAI,IAAI,IAAI,IAAI,CAACiH,YAAY,EAAE;MAC1C,MAAMpD,OAAO,GAAG,IAAI,CAACoD,YAAY,CAACQ,IAAI,CAAC,IAAI,CAACH,WAAW,CAAC;MACxD,IAAI,IAAI,IAAIzD,OAAO,EAAE;QACjB;QACA,IAAI,CAACnD,IAAI,CAACmC,iBAAiB,CAAC,MAAM;UAC9BgB,OAAO,CAAC6D,kBAAkB,CAAEC,CAAC,IAAK;YAC9B3H,GAAG,CAAC4H,WAAW,CAACD,CAAC,CAACE,IAAI,CAAC;UAC3B,CAAC,CAAC;UACFhE,OAAO,CAACiE,gBAAgB,CAAEH,CAAC,IAAK;YAC5B3H,GAAG,CAAC0G,QAAQ,CAACiB,CAAC,CAACE,IAAI,CAAC;UACxB,CAAC,CAAC;QACN,CAAC,CAAC;MACN;IACJ;EACJ;AACJ;AACAd,sBAAsB,CAACxB,IAAI;EAAA,iBAAwFwB,sBAAsB,EArPtCvH,EAAE,mBAqPsDyB,gBAAgB,GArPxEzB,EAAE,mBAqPmFA,EAAE,CAACuI,eAAe,GArPvGvI,EAAE,mBAqPkHA,EAAE,CAACiG,MAAM;AAAA,CAA4C;AAC5QsB,sBAAsB,CAACrB,IAAI,kBAtPwElG,EAAE;EAAA,MAsPEuH,sBAAsB;EAAA;EAAA;IAAA;EAAA;AAAA,EAA+F;AAC5N;EAAA,mDAvPmGvH,EAAE,mBAuPVuH,sBAAsB,EAAc,CAAC;IACpHpB,IAAI,EAAEjG,SAAS;IACfkG,IAAI,EAAE,CAAC;MACCC,QAAQ,EAAE;IACd,CAAC;EACT,CAAC,CAAC,EAAkB,YAAY;IAAE,OAAO,CAAC;MAAEF,IAAI,EAAE1E;IAAiB,CAAC,EAAE;MAAE0E,IAAI,EAAEnG,EAAE,CAACuI;IAAgB,CAAC,EAAE;MAAEpC,IAAI,EAAEnG,EAAE,CAACiG;IAAO,CAAC,CAAC;EAAE,CAAC,EAAkB;IAAE2B,MAAM,EAAE,CAAC;MAChJzB,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,eAAe;IAC1B,CAAC;EAAE,CAAC;AAAA;AAEhB,MAAMoC,2BAA2B,CAAC;EAC9B9G,WAAW,GAAG;IACV,IAAI,CAAC+G,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,WAAW,GAAG,CAAC;EACxB;EACAC,OAAO,GAAG;IACN,OAAO,EAAE,IAAI,CAACH,aAAa,KAAK,CAAC,IAAI,IAAI,CAACC,aAAa,KAAK,CAAC,IAAI,IAAI,CAACC,WAAW,KAAK,CAAC,CAAC;EAC5F;AACJ;AAEA,MAAME,2BAA2B,CAAC;EAC9BnH,WAAW,CAACR,IAAI,EAAE4H,kBAAkB,EAAE;IAClC,IAAI,CAAC5H,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC4H,kBAAkB,GAAGA,kBAAkB;EAChD;EACAC,gBAAgB,GAAG;IACf,OAAO,IAAI,CAACC,aAAa;EAC7B;EACAxC,IAAI,CAACyC,aAAa,EAAEC,cAAc,EAAE;IAChC,MAAMC,UAAU,GAAGF,aAAa,CAACE,UAAU,IAAI,CAAC,CAAC;IACjD,MAAMC,QAAQ,GAAGH,aAAa,CAACG,QAAQ,IAAI,CAAC,CAAC;IAC7C;IACA,IAAI,CAAClI,IAAI,CAACmC,iBAAiB,CAAC,MAAM;MAC9B,IAAI,CAAC2F,aAAa,GAAGvI,OAAO,CAACmH,MAAM,CAACuB,UAAU,EAAEC,QAAQ,EAAEF,cAAc,CAAC;IAC7E,CAAC,CAAC;IACF,IAAI,CAACJ,kBAAkB,CAACtH,IAAI,CAAC,IAAI,CAACwH,aAAa,CAAC;IAChD,OAAO,IAAI,CAACA,aAAa;EAC7B;EACAK,qBAAqB,CAAChF,OAAO,EAAE;IAC3B,IAAIiF,OAAO,GAAG,IAAId,2BAA2B,EAAE;IAC/C,IAAI,IAAI,IAAI,IAAI,CAACQ,aAAa,EAAE;MAC5BM,OAAO,GAAG,IAAI,CAACC,YAAY,CAAClF,OAAO,EAAE,IAAI,CAAC2E,aAAa,CAACQ,YAAY,CAAC;IACzE;IACA,OAAOF,OAAO;EAClB;EACAG,mBAAmB,CAACpF,OAAO,EAAE;IACzB,IAAIiF,OAAO,GAAG,IAAId,2BAA2B,EAAE;IAC/C,IAAI,IAAI,IAAI,IAAI,CAACQ,aAAa,EAAE;MAC5BM,OAAO,GAAG,IAAI,CAACC,YAAY,CAAClF,OAAO,EAAE,IAAI,CAAC2E,aAAa,CAACU,UAAU,CAAC;IACvE;IACA,OAAOJ,OAAO;EAClB;EACAC,YAAY,CAAClF,OAAO,EAAEsF,KAAK,EAAE;IACzB,MAAML,OAAO,GAAG,IAAId,2BAA2B,EAAE;IACjD,IAAI,IAAI,IAAInE,OAAO,EAAE;MACjB;MACA,IAAI,CAACnD,IAAI,CAACmC,iBAAiB,CAAC,MAAM;QAC9BgB,OAAO,CAACuF,kBAAkB,CAAEzB,CAAC,IAAK;UAC9B,IAAI,CAACa,aAAa,CAACZ,WAAW,CAACD,CAAC,CAACpB,aAAa,CAAC;UAC/C4C,KAAK,CAACE,IAAI,CAAC,IAAI,CAACb,aAAa,EAAEb,CAAC,CAAC7D,YAAY,EAAE6D,CAAC,CAAC2B,GAAG,CAAC;UACrDR,OAAO,CAACZ,aAAa,EAAE;QAC3B,CAAC,CAAC;QACFrE,OAAO,CAAC6D,kBAAkB,CAAEC,CAAC,IAAK;UAC9B,IAAI,CAACa,aAAa,CAACZ,WAAW,CAACD,CAAC,CAACpB,aAAa,CAAC;UAC/CuC,OAAO,CAACb,aAAa,EAAE;QAC3B,CAAC,CAAC;QACFpE,OAAO,CAACiE,gBAAgB,CAAEH,CAAC,IAAK;UAC5BwB,KAAK,CAACE,IAAI,CAAC,IAAI,CAACb,aAAa,EAAEb,CAAC,CAAC7D,YAAY,EAAE6D,CAAC,CAAC2B,GAAG,CAAC;UACrDR,OAAO,CAACX,WAAW,EAAE;QACzB,CAAC,CAAC;MACN,CAAC,CAAC;IACN;IACA,OAAOW,OAAO;EAClB;AACJ;AAEA,MAAMS,0BAA0B,CAAC;EAC7BrI,WAAW,GAAG;IACV,IAAI,CAACyH,UAAU,GAAG,CAAC,CAAC;IACpB,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC;EACtB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMY,6BAA6B,CAAC;EAChCtI,WAAW,CAAC6E,gBAAgB,EAAEiB,OAAO,EAAEtG,IAAI,EAAE;IACzC,IAAI,CAACsG,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACtG,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC4H,kBAAkB,GAAG,IAAI7I,YAAY,EAAE;IAC5C,IAAI,CAACsG,gBAAgB,GAAG,IAAID,uBAAuB,CAACC,gBAAgB,CAAC;IACrE,IAAI,CAAC0D,aAAa,GAAG,IAAIpB,2BAA2B,CAAC,IAAI,CAAC3H,IAAI,EAAE,IAAI,CAAC4H,kBAAkB,CAAC;IACxF;IACA,IAAI,CAACoB,gBAAgB,GAAG,IAAI,CAAC1C,OAAO,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC,CAACC,MAAM,EAAE;IACtD,IAAI,CAACwC,cAAc,GAAG,IAAI,CAAC3C,OAAO,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC,CAACC,MAAM,EAAE;EACxD;EACA,IAAIyC,mBAAmB,CAACvC,CAAC,EAAE;IACvB;IACA,IAAI,IAAI,IAAIA,CAAC,EAAE;MACXA,CAAC,GAAG,IAAIkC,0BAA0B,EAAE;IACxC;IACA,IAAI,IAAI,IAAIlC,CAAC,CAACsB,UAAU,EAAE;MACtBtB,CAAC,CAACsB,UAAU,GAAG,CAAC,CAAC;IACrB;IACA,IAAI,IAAI,IAAItB,CAAC,CAACuB,QAAQ,EAAE;MACpBvB,CAAC,CAACuB,QAAQ,GAAG,CAAC,CAAC;IACnB;IACA;IACA,IAAI,CAACiB,wBAAwB,GAAGxC,CAAC;IACjC;IACA,IAAI,CAACE,YAAY,EAAE;EACvB;EACA,IAAIqC,mBAAmB,GAAG;IACtB,OAAO,IAAI,CAACC,wBAAwB;EACxC;EACAjH,QAAQ,GAAG;IACP;IACA,IAAI,CAACmD,gBAAgB,CAACC,IAAI,EAAE;IAC5B;IACA,IAAI,CAACtF,IAAI,CAACmC,iBAAiB,CAAC,MAAM;MAC9B;MACA,IAAI,CAAC4G,aAAa,CACbzD,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC8D,oBAAoB,CAAC,CACnCC,KAAK,CAAC,IAAI,CAAChE,gBAAgB,CAAC5B,MAAM,EAAE,CAAC;IAC9C,CAAC,CAAC;IACF,IAAI,CAACoD,YAAY,EAAE;EACvB;EACAtD,WAAW,GAAG;IACV,IAAI,CAAC2F,mBAAmB,GAAG;MAAEjB,UAAU,EAAE,CAAC,CAAC;MAAEC,QAAQ,EAAE,CAAC;IAAE,CAAC;IAC3D,IAAI,CAACa,aAAa,CAAClB,gBAAgB,EAAE,CAACrE,MAAM,EAAE;EAClD;EACAsD,SAAS,GAAG;IACR,IAAI,CAACD,YAAY,EAAE;EACvB;EACAA,YAAY,GAAG;IACX,MAAMvH,GAAG,GAAG,IAAI,CAAC+F,gBAAgB,CAAC5B,MAAM,EAAE;IAC1C,MAAMqE,aAAa,GAAG,IAAI,CAACiB,aAAa,CAAClB,gBAAgB,EAAE;IAC3D,IAAI,IAAI,IAAIvI,GAAG,IAAI,IAAI,IAAIwI,aAAa,EAAE;MACtC;MACA,IAAI,IAAI,IAAI,IAAI,CAACkB,gBAAgB,IAAI,IAAI,IAAI,IAAI,CAACG,wBAAwB,CAAClB,UAAU,EAAE;QACnF,MAAM9E,OAAO,GAAG,IAAI,CAAC6F,gBAAgB,CAACjC,IAAI,CAAC,IAAI,CAACoC,wBAAwB,CAAClB,UAAU,CAAC;QACpF,IAAI,CAACc,aAAa,CAACZ,qBAAqB,CAAChF,OAAO,CAAC;MACrD;MACA;MACA,IAAI,IAAI,IAAI,IAAI,CAAC8F,cAAc,IAAI,IAAI,IAAI,IAAI,CAACE,wBAAwB,CAACjB,QAAQ,EAAE;QAC/E,MAAM/E,OAAO,GAAG,IAAI,CAAC8F,cAAc,CAAClC,IAAI,CAAC,IAAI,CAACoC,wBAAwB,CAACjB,QAAQ,CAAC;QAChF,IAAI,CAACa,aAAa,CAACR,mBAAmB,CAACpF,OAAO,CAAC;MACnD;IACJ;EACJ;AACJ;AACA2F,6BAA6B,CAACjE,IAAI;EAAA,iBAAwFiE,6BAA6B,EAvZpDhK,EAAE,mBAuZoEyB,gBAAgB,GAvZtFzB,EAAE,mBAuZiGA,EAAE,CAACwK,eAAe,GAvZrHxK,EAAE,mBAuZgIA,EAAE,CAACiG,MAAM;AAAA,CAA4C;AAC1R+D,6BAA6B,CAAC9D,IAAI,kBAxZiElG,EAAE;EAAA,MAwZSgK,6BAA6B;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;IAAA;EAAA;AAAA,EAAoR;AAC/Z;EAAA,mDAzZmGhK,EAAE,mBAyZVgK,6BAA6B,EAAc,CAAC;IAC3H7D,IAAI,EAAEjG,SAAS;IACfkG,IAAI,EAAE,CAAC;MACCC,QAAQ,EAAE;IACd,CAAC;EACT,CAAC,CAAC,EAAkB,YAAY;IAAE,OAAO,CAAC;MAAEF,IAAI,EAAE1E;IAAiB,CAAC,EAAE;MAAE0E,IAAI,EAAEnG,EAAE,CAACwK;IAAgB,CAAC,EAAE;MAAErE,IAAI,EAAEnG,EAAE,CAACiG;IAAO,CAAC,CAAC;EAAE,CAAC,EAAkB;IAAEmE,mBAAmB,EAAE,CAAC;MAC7JjE,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,sBAAsB;IACjC,CAAC,CAAC;IAAEkE,oBAAoB,EAAE,CAAC;MACvBnE,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,6BAA6B;IACxC,CAAC,CAAC;IAAE0C,kBAAkB,EAAE,CAAC;MACrB3C,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,2BAA2B;IACtC,CAAC;EAAE,CAAC;AAAA;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMqE,0BAA0B,CAAC;EAC7B/I,WAAW,CAAC6E,gBAAgB,EAAEiB,OAAO,EAAEtG,IAAI,EAAE;IACzC,IAAI,CAACsG,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACtG,IAAI,GAAGA,IAAI;IAChB;IACA,IAAI,CAAC4H,kBAAkB,GAAG,IAAI7I,YAAY,EAAE;IAC5C,IAAI,CAACsG,gBAAgB,GAAG,IAAID,uBAAuB,CAACC,gBAAgB,CAAC;IACrE,IAAI,CAAC0D,aAAa,GAAG,IAAIpB,2BAA2B,CAAC,IAAI,CAAC3H,IAAI,EAAE,IAAI,CAAC4H,kBAAkB,CAAC;IACxF,IAAI,CAACoB,gBAAgB,GAAG,IAAI,CAAC1C,OAAO,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC,CAACC,MAAM,EAAE;EAC1D;EACA;EACA,IAAIwB,UAAU,CAACtB,CAAC,EAAE;IACd,IAAI,CAAC6C,eAAe,GAAG7C,CAAC;IACxB,IAAI,CAAC8C,gBAAgB,EAAE;EAC3B;EACA,IAAIxB,UAAU,GAAG;IACb,OAAO,IAAI,CAACuB,eAAe;EAC/B;EACAjG,WAAW,GAAG;IACV,IAAI,CAAC0E,UAAU,GAAG,CAAC,CAAC;IACpB,IAAI,IAAI,IAAI,IAAI,CAACc,aAAa,CAAClB,gBAAgB,EAAE,EAAE;MAC/C,IAAI,CAACkB,aAAa,CAAClB,gBAAgB,EAAE,CAACrE,MAAM,EAAE;IAClD;EACJ;EACAtB,QAAQ,GAAG;IACP;IACA,IAAI,CAACmD,gBAAgB,CAACC,IAAI,EAAE;IAC5B;IACA,IAAI,CAACtF,IAAI,CAACmC,iBAAiB,CAAC,MAAM;MAC9B;MACA,IAAI,CAAC4G,aAAa,CACbzD,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC8D,oBAAoB,CAAC,CACnCC,KAAK,CAAC,IAAI,CAAChE,gBAAgB,CAAC5B,MAAM,EAAE,CAAC;IAC9C,CAAC,CAAC;IACF,IAAI,CAACgG,gBAAgB,EAAE;EAC3B;EACA3C,SAAS,GAAG;IACR,IAAI,CAAC2C,gBAAgB,EAAE;EAC3B;EACAA,gBAAgB,GAAG;IACf,MAAMnK,GAAG,GAAG,IAAI,CAAC+F,gBAAgB,CAAC5B,MAAM,EAAE;IAC1C,MAAMqE,aAAa,GAAG,IAAI,CAACiB,aAAa,CAAClB,gBAAgB,EAAE;IAC3D,IAAI,IAAI,IAAIvI,GAAG,IAAI,IAAI,IAAIwI,aAAa,IAAI,IAAI,IAAI,IAAI,CAACkB,gBAAgB,EAAE;MACvE,MAAM7F,OAAO,GAAG,IAAI,CAAC6F,gBAAgB,CAACjC,IAAI,CAAC,IAAI,CAACyC,eAAe,CAAC;MAChE,MAAMpB,OAAO,GAAG,IAAI,CAACW,aAAa,CAACZ,qBAAqB,CAAChF,OAAO,CAAC;MACjE,IAAIiF,OAAO,CAACV,OAAO,EAAE,EAAE;QACnB,IAAI,CAACgC,aAAa,EAAE;MACxB;IACJ;EACJ;EACA;AACJ;AACA;EACIA,aAAa,GAAG;IACZ,MAAMpK,GAAG,GAAG,IAAI,CAAC+F,gBAAgB,CAAC5B,MAAM,EAAE;IAC1C,MAAMiD,MAAM,GAAGjH,WAAW,CAACC,UAAU,CAAC,IAAI,CAACuI,UAAU,CAAC;IACtD,IAAI0B,UAAU;IACd;IACArK,GAAG,CAACsK,SAAS,CAAE3D,CAAC,IAAK;MACjB0D,UAAU,GAAGjD,MAAM,CAACF,IAAI,CAAEqD,EAAE,IAAM5D,CAAC,KAAK4D,EAAG,CAAC;IAChD,CAAC,CAAC;IACF;IACA,IAAI,IAAI,IAAIF,UAAU,EAAE;MACpB;MACA,IAAI,CAACG,SAAS,GAAGH,UAAU;IAC/B,CAAC,MACI;MACD;MACA,IAAIjD,MAAM,CAACtG,MAAM,GAAG,CAAC,EAAE;QACnB,IAAI,CAAC0J,SAAS,GAAGpD,MAAM,CAAC,CAAC,CAAC;QAC1B;QACA,IAAI,CAAC1G,IAAI,CAACmC,iBAAiB,CAAC,MAAM;UAC9B,IAAI,CAAC2H,SAAS,CAACT,KAAK,CAAC/J,GAAG,CAAC;QAC7B,CAAC,CAAC;MACN;IACJ;EACJ;AACJ;AACAiK,0BAA0B,CAAC1E,IAAI;EAAA,iBAAwF0E,0BAA0B,EAlgB9CzK,EAAE,mBAkgB8DyB,gBAAgB,GAlgBhFzB,EAAE,mBAkgB2FA,EAAE,CAACwK,eAAe,GAlgB/GxK,EAAE,mBAkgB0HA,EAAE,CAACiG,MAAM;AAAA,CAA4C;AACpRwE,0BAA0B,CAACvE,IAAI,kBAngBoElG,EAAE;EAAA,MAmgBMyK,0BAA0B;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;IAAA;EAAA;AAAA,EAA4P;AACjY;EAAA,mDApgBmGzK,EAAE,mBAogBVyK,0BAA0B,EAAc,CAAC;IACxHtE,IAAI,EAAEjG,SAAS;IACfkG,IAAI,EAAE,CAAC;MACCC,QAAQ,EAAE;IACd,CAAC;EACT,CAAC,CAAC,EAAkB,YAAY;IAAE,OAAO,CAAC;MAAEF,IAAI,EAAE1E;IAAiB,CAAC,EAAE;MAAE0E,IAAI,EAAEnG,EAAE,CAACwK;IAAgB,CAAC,EAAE;MAAErE,IAAI,EAAEnG,EAAE,CAACiG;IAAO,CAAC,CAAC;EAAE,CAAC,EAAkB;IAAEkD,UAAU,EAAE,CAAC;MACpJhD,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,mBAAmB;IAC9B,CAAC,CAAC;IAAEkE,oBAAoB,EAAE,CAAC;MACvBnE,IAAI,EAAEhG,KAAK;MACXiG,IAAI,EAAE,CAAC,6BAA6B;IACxC,CAAC,CAAC;IAAE0C,kBAAkB,EAAE,CAAC;MACrB3C,IAAI,EAAE/F,MAAM;MACZgG,IAAI,EAAE,CAAC,2BAA2B;IACtC,CAAC;EAAE,CAAC;AAAA;AAEhB,MAAM6E,aAAa,CAAC;AAEpBA,aAAa,CAAClF,IAAI;EAAA,iBAAwFkF,aAAa;AAAA,CAAkD;AACzKA,aAAa,CAACC,IAAI,kBAvhBiFlL,EAAE;EAAA,MAuhBMiL;AAAa,EAQlF;AACtCA,aAAa,CAACE,IAAI,kBAhiBiFnL,EAAE,qBAgiBsB;AAC3H;EAAA,mDAjiBmGA,EAAE,mBAiiBViL,aAAa,EAAc,CAAC;IAC3G9E,IAAI,EAAE7F,QAAQ;IACd8F,IAAI,EAAE,CAAC;MACCgF,OAAO,EAAE,CACL3J,gBAAgB,EAChBgF,qBAAqB,EACrBc,sBAAsB,EACtByC,6BAA6B,EAC7BS,0BAA0B,CAC7B;MACDY,YAAY,EAAE,CACV5J,gBAAgB,EAChBgF,qBAAqB,EACrBc,sBAAsB,EACtByC,6BAA6B,EAC7BS,0BAA0B;IAElC,CAAC;EACT,CAAC,CAAC;AAAA;AAEV,MAAMa,0BAA0B,CAAC;EAC7B5J,WAAW,CAACyE,IAAI,EAAEoF,GAAG,EAAEpJ,OAAO,EAAE;IAC5B,IAAI,CAACgE,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACoF,GAAG,GAAGA,GAAG;IACd,IAAI,CAACpJ,OAAO,GAAGA,OAAO;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOqJ,eAAe,CAACC,QAAQ,EAAE;IAC7B,IAAI7E,KAAK;IACT,QAAQ6E,QAAQ,CAACtF,IAAI;MACjB,KAAK,KAAK;QACNS,KAAK,GAAGlG,SAAS,CAAC+K,QAAQ,CAACF,GAAG,EAAEE,QAAQ,CAACtJ,OAAO,CAAC;QACjD;MACJ,KAAK,KAAK;MACV;QACIyE,KAAK,GAAGlG,SAAS,CAACgL,GAAG,CAACD,QAAQ,CAACF,GAAG,EAAEE,QAAQ,CAACtJ,OAAO,CAAC;QACrD;IAAM;IAEd,OAAOyE,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAO+E,gBAAgB,CAACC,SAAS,EAAE;IAC/B,MAAMhE,MAAM,GAAG,CAAC,CAAC;IACjB,KAAK,MAAM9G,CAAC,IAAI8K,SAAS,EAAE;MACvB,IAAIA,SAAS,CAAC7K,cAAc,CAACD,CAAC,CAAC,EAAE;QAC7B8G,MAAM,CAAC9G,CAAC,CAAC,GAAIwK,0BAA0B,CAACE,eAAe,CAACI,SAAS,CAAC9K,CAAC,CAAC,CAAE;MAC1E;IACJ;IACA,OAAO8G,MAAM;EACjB;EACA;AACJ;AACA;AACA;AACA;EACI4D,eAAe,GAAG;IACd,OAAOF,0BAA0B,CAACE,eAAe,CAAC,IAAI,CAAC;EAC3D;AACJ;;AAEA;AACA;AACA;;AAEA,SAASf,0BAA0B,EAAEjC,2BAA2B,EAAEuB,0BAA0B,EAAElB,2BAA2B,EAAEpH,gBAAgB,EAAE6E,uBAAuB,EAAEG,qBAAqB,EAAEuD,6BAA6B,EAAEzC,sBAAsB,EAAE0D,aAAa,EAAEK,0BAA0B,EAAE3K,WAAW;AAC1S"},"metadata":{},"sourceType":"module","externalDependencies":[]}